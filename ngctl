#!/bin/bash

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>



# First things first. Do we want debug?
st_debug=0

echo "$@" | grep "\-\-debug=1" &> /dev/null
if [ $? -eq 0 ]; then
    st_debug=1
fi

echo "$@" | grep "\-\-debug=2" &> /dev/null
if [ $? -eq 0 ]; then
    st_debug=2
fi

# Some important stuff - set these to match your environment
# Use --defaults to specify an override config file, or create
# a defaults file '/etc/ngctl.defaults' or './ngctld.efaults' ( code search: # SETTING_DEFAULTS)
env_livestatus='/var/spool/nagios/cmd/live'         # live status socket for LQL queries
env_cmdpipe='/var/log/nagios/rw/nagios.cmd'         # nagios command pipe
env_server_prefix_regex='prod|dr|fake'             # valid prefixes for server names
ngq_filename=/etc/nagios/ngctlq.conf                # config file name for query mode


# For development purposes set this.  Functions that require interaction with a functioning
# Nagios server will instead return fake data.
#   Set to 0 = don't fake data
#   Set to 1 = return a successful response
#   Set to 2 = return an unsuccessful response

devMode=0

echo "$@" | grep "\-\-devMode=1" &> /dev/null
if [ $? -eq 0 ]; then
    devMode=1
fi

echo "$@" | grep "\-\-devMode=2" &> /dev/null
if [ $? -eq 0 ]; then
    devMode=2
fi

# Some console colour codes
    # Foreground colours
    fg_red="\e[31m\e[1m"
    fg_green="\e[32m"
    fg_yellow="\e[33m"
    fg_blue="\e[36m"
    fg_purple="\e[95m"

    # Background colours
    bg_red="\e[41m"
    bg_green="\e[42m"
    bg_yellow="\e[43m"
    bg_blue="\e[46m"
    bg_purple="\e[105m"
    bg_grey="\e[100m"

    # Other formatting
    fg_bold="\e[1m"
    fg_reverse="\e[7m"
    fg_underline="\e[4m"

    # Console resets
    fg_reset="\e[39m"
    bg_reset="\e[49m"
    fbg_reset="\e[0m"


# Instead of 'echo'ing everything, use a custom function to format output
out (){
    case "$1" in
        info)
            printf "$fg_blue$2$fbg_reset"
            ;;
        INFO)
            printf "$bg_blue$2$fbg_reset"
            ;;
        ok)
            printf "$fg_green$2$fbg_reset"
            ;;
        OK)
            printf "$bg_green$2$fbg_reset"
            ;;
        debug)
            if [ $st_debug -gt 0 ] || [ $st_debug -eq 2 ];then
                printf "$bg_grey";echo -e "$@$fbg_reset"
                return 0
            fi
            ;;
        DEBUG)
            if [ $st_debug -eq 2 ];then
                printf "$fg_bold$bg_grey";echo -e "$@$fbg_reset"
                return 0
            fi
            ;;            
        hint)
            printf "\t$fg_purple""Hint:\t$2$fbg_reset"
            ;;
        HINT)
            printf "\t$bg_purple""Hint:\t$2$fbg_reset"
            ;;             
        err)
            printf "$fg_red$2$fbg_reset\n" > /dev/stderr
            return 1
            ;;
        ERR)
            printf "$bg_red$2$fbg_reset\n" > /dev/stderr
            return 1
            ;;
    esac
}

# IMPORTANT - newline characters should not be allowed at all in the parameters
badParmaetersCheck(){
  out debug "Starting bad parameter check"
  originalParams="$@"
#   echo Original params = $originalParams
  fatalParams=0
  checkedSpecial=${originalParams//[$'\n\t\r']}
  if [ "$originalParams" != "$checkedSpecial" ]; then
    out DEBUG "Found bad special characters"
    out ERR "Tab, new-line and carridge returns are not permitted"
    fatalParams=1
  fi
   specialChars=('\\n' '\\t' '\\r')
  checkChars=$originalParams
  for char in ${specialChars[@]}; do
    checkChars=${checkChars/$char/ }
  done
  if [ "$originalParams" != "$checkChars" ]; then
    out DEBUG "Found bad escaped special characters"
    out ERR "Escaped tab, new-line and carridge returns are not permitted"
    fatalParams=1
  fi
  if [ $fatalParams -eq 1 ]; then
    out debug "Finished bad parameter check"
    exit 21
  fi
  out debug "Finished bad parameter check"
}
badParmaetersCheck "$@"

case "$1" in 
    down)
        ng_mode=down
        out debug "We are in downtime mode"
        ;;

    ack)
        ng_mode=ack
        out debug "We are in acknowledge mode"
        ;;

    query)
        ng_mode=query
        out debug "We are in query mode"
        ;;
    
    up)
        ng_mode=up
        out debug "We are in up mode"
        ;;

    remove-downtime|rd)
        ng_mode=rmdown
        out debug "We are in remove-downtime mode"
        ;;
    
    enable-checks|ec)
        ng_mode=encheck
        out debug "We are in enable-check mode"
        ;;

    disable-checks|dc)
            ng_mode=discheck
            out debug "We are in disable-check mode"
            ;;

    enable-notifcations|en)
            ng_mode=ennotif
            out debug "We are in enable-notifications mode"
            ;;

    disable-notifications|dn)
            ng_mode=disnotif
            out debug "We are in disable-notifications mode"
            ;;

    schedule-check|sc)
            ng_mode=scheck
            out debug "We are in schedule-check mode"
            ;;
    *)
        ng_mode=down
        out debug "We are defaulting to downtime mode as no recognised mode specified as first parameter"
        ;;

esac

# ---------------------------------------------------------------------------------------------------------
#  Help sections

help-basic (){
    printf "$fg_bold"Use:"$fbg_reset ngctl [mode] [parameters]\n"
    printf "\n"
    printf "(ngctl --Help for more detailed help)\n"
    printf "\n"
    printf "$fg_bold"Modes"$fbg_reset\n"
    printf "  $fg_bold*$fbg_reset down    add a host or service downtime\n"
    printf "  $fg_bold*$fbg_reset up      remove a host or service downtime\n"
    printf "  $fg_bold*$fbg_reset rd      remove a host or service downtime by ID\n"
    printf "  $fg_bold*$fbg_reset ack     acknowledge host or service problems\n"
    printf "  $fg_bold*$fbg_reset dn      Disable host or service notifications\n"
    printf "  $fg_bold*$fbg_reset en      Enable host or service notifications\n"
    printf "  $fg_bold*$fbg_reset dc      Disable host or service checks\n"
    printf "  $fg_bold*$fbg_reset ec      Enable host or service checks\n"
    printf "  $fg_bold*$fbg_reset sc      Schedule host or service check\n"
    printf "  $fg_bold*$fbg_reset query   Query Nagios using LQL\n"
    printf "\n"
    printf "$fg_bold"Parameters"$fbg_reset\n"
    printf "  $fg_underline"Note:"$fbg_reset parameters with values must be specified by parameter=value, e.g. -x=1\n"
    printf "          not all parameters require a value, e.g. -v\n"
    printf "\n"
    printf "\n"
    printf "  -b      begin time of a downtime\n"
    printf "  -c      comment\n"
    printf "  -d      duration in minutes\n"
    printf "  -D      duration in hours\n"
    printf "  -e      end time of a downtime\n"
    printf "  -h      hostname or hostname template\n"
    printf "  -H      hostgroup name\n"
    printf "  -i      downtime ID\n"
    printf "  -k      sticky acknowledge\n"
    printf "  -n      notify acknowledge\n"
    printf "  -o      override hostname validation\n"
    printf "  -p      parity of range\n"
    printf "  -q      quiet\n"
    printf "  -Q      query name\n"
    printf "  -r      command retries\n"
    printf "  -R      validate retries \n"
    printf "  -s      service description\n"
    printf "  -S      state\n"
    printf "  -t      test parameter use\n"
    printf "  -u      username\n"
    printf "  -v      verbose\n"
    printf "  -V      very verbose\n"
    printf "  -x      range start\n"
    printf "  -y      range end\n"
    printf "  -z      validate pause\n"
    printf "  -Z      command pause\n"
    printf "\n"
    printf "  --all       schedule checking of all services on a host\n"
    printf "  --force     force scheduling of checks on host or services\n"
    printf "  --my        my downtimes entries ('up' mode)\n"
    printf "  --config    override query config filename\n"
    printf "  --custom    custom query values\n"
    printf "  --null      output when result of a query is null\n"
    printf "  --query     LQL query\n"
    printf "  --debug     debug level\n"
    printf "  --help      help\n"
    printf "  --list      list pre-defined queries\n"
    printf "  --validate  validate query config file\n"
}

help-detailed (){
    printf "$fg_bold"Use:"$fbg_reset ngctl [mode] [parameters]\n"
    printf "\n"
    printf "$fg_bold"Modes"$fbg_reset\n"
    printf "  $fg_bold*$fbg_reset down    add a host or service downtime\n"
    printf "  $fg_bold*$fbg_reset up      remove a host or service downtime\n"
    printf "  $fg_bold*$fbg_reset rd      remove a host or service downtime by ID\n"
    printf "  $fg_bold*$fbg_reset ack     acknowledge host or service problems\n"
    printf "  $fg_bold*$fbg_reset dn      Disable host or service notifications\n"
    printf "  $fg_bold*$fbg_reset en      Enable host or service notifications\n"
    printf "  $fg_bold*$fbg_reset dc      Disable host or service checks\n"
    printf "  $fg_bold*$fbg_reset ec      Enable host or service checks\n"
    printf "  $fg_bold*$fbg_reset sc      Schedule host or service check\n"
    printf "  $fg_bold*$fbg_reset query   Query Nagios using LQL\n"
    printf "\n"
    printf "$fg_bold"Parameters"$fbg_reset\n"
    printf "  $fg_underline"Note:"$fbg_reset parameters with values must be specified by parameter=value, e.g. -x=1\n"
    printf "          not all parameters require a value, e.g. -v\n"
    printf "\n"
    printf "  -b      begin time of a downtime\n"
    printf "          a string representing a time compatible with the 'date' command\n"
    printf "          Examples:   -b='Tomorrow 8am'\n"
    printf "                      -b='2019-10-31 8:00'\n"
    printf "\n"
    printf "  -c      comment\n"
    printf "          a string, required for setting downtimes or acknowledging problems\n"
    printf "\n"
    printf "  -d      duration in minutes\n"
    printf "          an integer (not valid if an end time is also specified)\n"
    printf "\n"
    printf "  -D      duration in hours\n"
    printf "          an integer (not valid if an end time is also specified)\n"
    printf "\n"
    printf "  -e      end time of a downtime\n"
    printf "          a string representing a time compatible with the 'date' command (not valid if duration in hours and/or minutes is also specified)\n"
    printf "\n"
    printf "  -h      hostname or hostname template\n"
    printf "          a string which begins with the configured prefixes. Can be specified multiple times for a hostname, or can be a quoted space delimited list of hostnames\n"
    printf "          If the hostname doesn't end with a number it will be treated as a hostname template, and can only be specified once\n"
    printf "          hostname templates require -x and -y and optionally -p may be specified\n"
    printf "\n"
    printf "  -H      hostgroup name\n"
    printf "          a string which is a Nagios hostgroup. Can be specified multiple times, or can be a quoted space delimited list of hostgroups\n"
    printf "          hostgroup can't be specified with a hostname template\n"
    printf "\n"
    printf "  -i      downtime ID\n"
    printf "          the ID of a downtime entry to remove\n"
    printf "\n"
    printf "  -k      sticky acknowledge\n"
    printf "          denotes an acknowledge command should be 'sticky'\n"
    printf "\n"
    printf "  -n      notify acknowledge\n"
    printf "          denotes an acknowledge command should be notify\n"
    printf "\n"
    printf "  -o      override\n"
    printf "          Denotes that hostname format checks should be ignored. Also disables templates and invalidates -x -y -p parameters\n"
    printf "\n"
    printf "  -p      parity\n"
    printf "          a string, eith "odd" or "even"\n"
    printf "          Only valid when specifying a hostname template - requires -x and -y\n"
    printf "\n"
    printf "  -q      quiet\n"
    printf "          Denotes that output should be limited\n"
    printf "\n"
    printf "  -Q      query name\n"
    printf "          the name of the predefined LQL query\n"
    printf "          Requires ngctlq.conf \n"
    printf "\n"
    printf "  -r      command retries\n"
    printf "          integer, number of times to retry sending a command to Nagios\n"
    printf "\n"
    printf "  -R      validate retries \n"
    printf "          integer, number of times to try validating a command was successful\n"
    printf "          this applies after each try as specified by -r \n"
    printf "\n"
    printf "  -s      service description\n"
    printf "          a string, the service description (aka name). Can be specified multiple times, or can be a quoted space delimited list of services\n"
    printf "\n"
    printf "  -S      state\n"
    printf "          either an integer between 0 and 3, or a string - one of OK WARN CRIT UNK (ok warn crit unk)\n"
    printf "          only valid in query mode\n"
    printf "\n"
    printf "  -t      test\n"
    printf "          denotes test mode.  No commands will be executed - used for checking parameter interpretation and validity\n"
    printf "\n"
    printf "  -u      username\n"
    printf "          a string, the username to use in query mode or up mode\n"
    printf "\n"
    printf "  -v      verbose\n"
    printf "          denotes output should be verbose\n"
    printf "\n"
    printf "  -V      very verbose\n"
    printf "          denotes output should be very verbose\n"
    printf "\n"
    printf "  -x      range start\n"
    printf "          an integer, the start number for a hostname template. Requires -y\n"
    printf "\n"
    printf "  -y      range end\n"
    printf "          an integer, the end number for a hostname template. Requires -x\n"
    printf "\n"
    printf "  -z      validate pause\n"
    printf "          a number (float), the time to pause after sending a command before trying to validate it's success\n"
    printf "\n"
    printf "  -Z      command pause\n"
    printf "          a number (float), the time to pause after validating a command before trying to send the next command\n"
    printf "\n"
    printf "  --all       schedule checking of all services on a host\n"
    printf "\n"
    printf "  --force     force scheduling of checks on host or services\n"
    printf "\n"
    printf "  --my        my downtimes entries\n"
    printf "              in 'up' mode find only current user's entries\n"
    printf "\n"
    printf "  --config    override query config filename\n"
    printf "              a string, a custom filename to override default ngctlq.conf file\n"
    printf "\n"
    printf "  --custom    custom query values\n"
    printf "              a space delimited string of values to be used in query mode for predefined LQL queries\n"
    printf "              * see the included ngctlq.conf file for more details\n"
    printf "\n"
    printf "  --null      what to output when result of a query is null, instead of null\n"
    printf "              a string. Example '0;No issues' for a service check query which normally produces no output\n"
    printf "\n"
    printf "  --query     specify LQL query, instead of using a predefined query\n"
    printf "              example: --query='GET services|Filter: state > 0|Columns: host_name description'\n"
    # using echo here is on purpose
    echo "              use either '|' or '\n' for new lines in the query"
    printf "\n"
    printf "  --debug     debug level\n"
    printf "              an integer, sets the debug output level. 1 is some, 2 is all\n"
    printf "\n"
    printf "  --devmode   enable devmode\n"
    printf "              partially implemented - for testing locally without a Nagios server.\n"
    printf "              see the script for more information\n"
    printf "\n"
    printf "  --help      basic help\n"
    printf "\n"
    printf "  --Help      extended help\n"
    printf "\n"
    printf "  --list      list queries\n"
    printf "              in query mode, list configured predefined queries\n"
    printf "\n"
    printf "  --validate  validate query config file\n"
    printf "              validtaes that the specified ngctlq.conf file is valid\n"
    printf "\n"    
}

# ---------------------------------------------------------------------------------------------------------


out DEBUG "Lots of debug enabled!"
out debug "Got parameters: $@"


# Set all "value provided" flags to 0; these are set when they are detected but not yet validated
#                          Used for reporting errors back to the user (close but no cigar)
fnd_hostname=0
fnd_hosttemplate=0
fnd_hostgroup=0
fnd_service=0
fnd_minutes=0
fnd_hours=0
fnd_comment=0
fnd_begintime=0
fnd_endtime=0
fnd_rangex=0
fnd_rangey=0
fnd_parity=0
fnd_query=0
fnd_nullquery=0
fnd_custom_query=0
fnd_filter=0
fnd_field=0
fnd_sleepz=0
fnd_sleepZ=0
fnd_query_name=0
fnd_state=0
fnd_username=0
fnd_custom=0
fnd_retry=0
fnd_validation_retry=0
fnd_config_filename=0
fnd_sticky=0
fnd_notify=0
fnd_dt_id=0
fnd_type=0

# Set all "value set" flags to 0; these are set when valid values have been found
# When set, we use binary decimals for some so we can do easier checking later
flg_hostname=0          # 1 when set
flg_hosttemplate=0      # 2 when set
flg_hostgroup=0         # 4 when set
flg_service=0           # 1 when set
flg_minutes=0           # 1 when set
flg_hours=0             # 2 when set
flg_begintime=0         # 4 when set
flg_endtime=0           # 8 when set
flg_rangex=0            # 1 when set
flg_rangey=0            # 2 when set
flg_parity=0            # 4 when set
flg_comment=0           # 1 when set
flg_filter=0            # 1 when set
flg_field=0             # 1 when set
flg_sleepz=0            # 1 when set
flg_sleepZ=0            # 1 when set
flg_query_name=0        # 1 when set
flg_nullquery=0         # 1 when set
flg_custom_query=0      # 1 when set
flg_config_filename=0   # 1 when set
flg_state=0             # 1 when set
flg_username=0          # 1 when set
flg_custom=0            # 1 when set
flg_retry=0             # 1 when set
flg_validation_retry=0  # 1 when set
flg_dt_id=0             # 1 when set
flg_type=0              # 1 when set
flg_error=0             # not a parameter, but we need it later

# These are set to 1 when detected as they take no value - they're there or they're not
flg_verbose=0
flg_veryverbose=0
flg_test=0
flg_quiet=0
flg_help=0
flg_fullhelp=0
flg_override=0
flg_list=0
flg_validate=0
flg_sticky=0
flg_notify=0
flg_my=0
flg_all=0
flg_force=0

# Initialise some misc variables
ng_error="\nValidation error(s)"
ng_hosttemplates=''
ng_hostnames=''
ng_services=''
ng_custom=''
ng_username=''
ng_sleepz=0.5
ng_sleepZ=0.1
ng_retry=5
ng_validation_retry=3
ng_command_minimum=0.0005   # 0.5ms minimum to execute and validate assuming no retries and no sleep times
                            # this is used by the schedule() function which attempts to calculate execution time
                            # This is for you Craig, and your crazy bash expansions. See -r -R -z -Z for tuning
                            # and use -t and -V
ng_debughacks=0         # this will be set to 1 if debughacks.inc is present

cmd_endtime=0           # the calculated end time
cmd_starttime=0         # the calculated start time
cmd_targets=''          # final list of host targets
cmd_services=''         # final list of services
comb_target=0           # 1 once valid target combination is found
comb_time=0             # 1 once valid times are found
comb_range=0            # 1 once valid range is found
func_time=0             # used by datefunc() to return it's value
hostgroup_hosts=''      # used by getHostsbyhostgroup() to set the list of hostnames


load_config() {
    allowed_vars="env_livestatus env_cmdpipe env_server_prefix_regex ngq_filename ng_sleepz ng_sleepZ ng_retry ng_validation_retry"
    for i in $allowed_vars; do
        cvar=$(grep ^$i= $1)
        if [ $? -eq 0 ]; then
            out DEBUG "Setting value $i from $1 ($cvar)"
            eval $cvar
        fi
    done
}

# SETTING_DEFAULTS
# Now check if a 'defaults' file is specified
# This can be used to override one or more of the defaults defined
# above. Use with caution as changing some will have weird effects.
# If it isn't in the provided ngctl.defaults it's probably a bad idea.

# Precedence of ngctl.defaults: local directory first, then /etc/ngctl.defaults,
# then a specified file. Last set wins.

# First check for ./ngctl.defaults and load it if it's there
if [ -r ./ngctl.defaults ]; then
    out DEBUG "Loading local file ./ngctl.defaults - if it breaks don't blame ngctl!"
    load_config ./ngctl.defaults
else
    out DEBUG "Defaults file ./ngctl.defaults doesn't exist or is not accessible"
fi

# Next check for /etc/ngctl.defaults and load it if it's there
if [ -r /etc/ngctl.defaults ]; then
    out DEBUG "Loading system file /etc/ngctl.defaults - if it breaks don't blame ngctl!"
    load_config /etc/ngctl.defaults
else
    out DEBUG "Defaults file /etc/ngctl.defaults doesn't exist or is not accessible"
fi

# Finally check if another defaults file has been specified
# This will override any previously defined defaults
fnd_defaults=0
flg_defaults=0
for switch in "$@"
do
    if [ "${switch:0:10}" == "--defaults" ]; then
        fnd_defaults=1
        if [ $flg_defaults -eq 1 ]; then
            out DEBUG "Found and ignoring another -defaults"
        else
            flg_defaults=1
            ng_defaults=${switch:11}
            out DEBUG "Found --defaults with value '$ng_defaults'"
        fi
    fi
done

if [ $flg_defaults -eq 1 ]; then
    if [ -r $ng_defaults ]; then
        out DEBUG "Loading specified file $ng_defaults - if it breaks don't blame ngctl!"
        load_config $ng_defaults
    else
        # If the file doesn't exist, exit immediately - unexpected results on the Nagios
        # instance might occur if overrides were not loaded as expected.
        out ERR "Defaults file $ng_defaults doesn't exist or is not accessible"
        exit 1
    fi
fi

# Some functions we need for various things
# We're only using functions where it doesn't obfuscate the flow too much, and provides an advantage in not replicating code;
# it should still be readable either immediately or having looked at the function once.

# For example:  dedupe $array
# hopefully indicates that the 'dedupe' function with remove duplicates from an array

# htype() takes a string which is checked to see if it is a valid hostname or hostname template, or why it's invalid
htype () {
    
    # Inputs:
    #   $1 string to be tested

    # Return codes:
    #   1   string is a hostname
    #   2   string is a hostname template
    #   99  string doesn't match prefix constraint
    #   100 string ends in a single number (not allowed)
    #   101 string contains inavlid characters for a hostname

    prefixregex=$env_server_prefix_regex
    testhost=$1

    # Check the testhost contains only allowed characters
    checkhost=$(echo $testhost | grep -Po "[A-Za-z0-9-]{1,}") 2>/dev/null
    if [ "$testhost" != "$checkhost" ]; then
        return 101
        break
    fi

    # Check that the testhost begins with a valid prefix
    echo $testhost | grep -Po "^($prefixregex)" &> /dev/null
    if [ $? -eq 1 ]; then
        return 99
        break
    fi

    # Check if testhost ends with 2 or 3 numbers - it's a hostname if so
    echo $testhost | grep -Po "\d{2,3}$" &>/dev/null
    if [ $? -eq 0 ]; then
        return 1
        break
    else
        # Lastly check if it ends in a single number (not allowed)
        echo $testhost | grep -Po "\d{1}$" &>/dev/null
        if [ $? -eq 0 ]; then
             return 100
             break;
        fi
        # If we're here it ought to fit hostname template
        return 2
        break
    fi
}

# isin() takes a string and an "array" - a string of space delimited strings
isin (){

    # Inputs:
    #   $1      String to find
    #   $2      Quoted space delimited string of strings

    # Return codes:
    #   0       String was found
    #   1       String was not found

    if [ $# -lt 2 ]; then
        return 99
    fi
    str_in=$1
    str_array=$2

    for i in $str_array; do
        if [ "$i" == $str_in ]; then
            return 0
        fi
    done
    return 1
}

# dedupe() removes duplicate items from a list
dedupe () {

    # Inputs:
    # $1 List of items

    # Ouputs:
    # $dedupe_result is set to depuded input List

    # Return codes:
    # 0 no duplicates found 
    # x number of duplicates removed

    dedupe_result=''
    dedupe_found=0

    out DEBUG "dedupe() starting with $@"

    for item in $@;
    do
        isin $item "$dedupe_result"
        isin_result=$?
        if [ $isin_result -eq 1 ]; then 
            if [ ${#dedupe_result} -gt 0 ]; then
                dedupe_result="$dedupe_result $item"
            else
                dedupe_result="$item"
            fi
        else
            dedupe_found=$(($dedupe_found + 1))
            out DEBUG removed duplicate $item
        fi
    done
    return $dedupe_found
}

# datefunc() takes an an action type and value
datefunc () {

    # Inputs:
    #   $1      type of request - hours and minutes output a value in seconds, absolute and now output unix timestamps
    #   $2      value to work on, either an integer or string to be converted. None for 'now'

    # Return coes:
    #   0       func_time has been set
    #   1       func_time has not been set - request failed

    if [ "$1" == "hours" ]; then
        func_time=$(($2 * 60 * 60))
        return $?
    elif [ "$1" == "minutes" ]; then
        func_time=$(($2 * 60))
        return $?
    elif [ "$1" == "absolute" ]; then
        func_time=$(date -d "$2" +%s)
        return $?
    elif [ "$1" == "now" ]; then
        func_time=$(date +%s)
        return $?
    elif [ "$1" == "unix" ]; then
        func_time=$(date -d @$2)
        return $?
    fi
    return 1
}

getHostsbygroup (){

    # Inputs:
    # $1 hostgroup name

    # Return codes:
    # 0 hostnames found and added to $hostgroup_hosts
    # 1 no hostnames found, invalid hostgroup
    out DEBUG "Getting list of hosts in hostgroup in mode $devMode"

    hostgroup_hosts=''    # Turns out this is important ;)

    if [ $devMode -eq 0 ]; then
        lql="GET hostsbygroup\nFilter: hostgroup_name = $1\nColumns: name\n"
        lql_result=$(echo -e "$lql" | unixcat $env_livestatus)
    elif [ $devMode -eq 1 ]; then
        out DEBUG "Returning fake successful data from getHostsbygroup($1)"
        lql_result=''
        i=1
        end=$(echo ${RANDOM:0:1})
        while [ $i -le $end ]; do 
            rnd=$(echo ${RANDOM:0:2})
            out DEBUG "Generated hostname fakehost$1$rnd"
            lql_result="$lql_result fakehost$1$rnd"
            i=$(($i+1))
        done
    else
        lql_result=''
    fi

    lql=''

    if [ ${#lql_result} -gt 0 ]; then
        for hg_host in $lql_result; do
            if [ ${#hostgroup_hosts} -gt 0 ]; then
                isin $hg_host "$hostgroup_hosts"
                dupcheck=$?
                out DEBUG "isin() returned $dupcheck" 
                if [ $dupcheck -eq 1 ]; then
                    out DEBUG "Adding $hg_host to hostgroup_hosts"
                    hostgroup_hosts="$hostgroup_hosts $hg_host"
                else
                    out DEBUG "Ignoring duplicate hostname $hg_host"
                fi
            else
                out DEBUG "Adding $hg_host to hostgroup_hosts"
                hostgroup_hosts=$hg_host
            fi
        done
        return 0
    else
        ng_error="$ng_error\n\tNo hosts found for hostgroup $1"
        flg_error=1
        return 1
    fi
}

# Sets flg_error to 1 if any query specific parameters are set
noQueryParams() {
    if [ $flg_config_filename -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tConfig file is not valid in $ng_mode mode")
    fi

    if [ $flg_validate -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tValidate is not valid in $ng_mode mode")
    fi

    if [ $flg_list -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tList is not valid in $ng_mode mode")
    fi

    if [ $flg_query_name -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tQuery name is not valid in $ng_mode mode")
    fi

    if [ $flg_state -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tState is not valid in $ng_mode mode")
    fi

    if [ $flg_custom -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tCustom values are not valid in $ng_mode mode")
    fi

    if [ $flg_nullquery -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tNull query value is not valid in $ng_mode mode")
    fi
}

# Sets flg_error to 1 if any ack specific parameters are set
noAckParams() {
    if [ $flg_sticky -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tSticky is not valid in $ng_mode mode")
    fi

    if [ $flg_notify -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tNotify is not valid in $ng_mode mode")
    fi
}

# Sets flg_error to 1 if any up specific parameters are set
noUpParams() {
    if [ $flg_my -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tMy is not valid in $ng_mode mode")
    fi

    if [ $flg_type -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tType is not valid in $ng_mode mode")
    fi
}

noScheckParams(){
    if [ $flg_all -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tAll is not valid in $ng_mode mode")
    fi
    if [ $flg_force -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tForce is not valid in $ng_mode mode")
    fi
}

# Sets flg_error to 1 if any rmdown specific parameters are set
noRmdownParams() {
    if [ $flg_dt_id -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tDowntime ID is not valid in $ng_mode mode")
    fi
}

# Sets flg_error to 1 if more than 1 host, hostgroup or service is specified
noMultipleHostsServices(){
    #   Check that we only have 1 hostname
    tmpArray=($ng_hostnames)
    if [ ${#tmpArray[@]} -gt 1 ]; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tMultiple hostnames are not valid in $ng_mode mode")
    fi

#   Check that we only have 1 hostgroup
    tmpArray=($ng_hostgroups)
    if [ ${#tmpArray[@]} -gt 1 ]; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tMultiple hostgroups are not valid in $ng_mode mode")
    fi

#   Check that we only have 1 service
    tmpArray=($cmd_services)
    if [ ${#tmpArray[@]} -gt 1 ]; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tMultiple services are not valid in $ng_mode mode")
    fi
}

removeDowntime(){

    cmd_dt_tries=1               # number of times we've tried sending the command
    cmd_validate_tries=1         # number of times we've tried to validate, afer each command try
    flg_command_success=0        # set to 1 once we've successfully validated the command

    while [ $flg_command_success -eq 0 ]  && [ $cmd_dt_tries -le $cmd_retries ];
    do
        ls_command="[%lu] DEL_HOST_DOWNTIME;$ng_dt_id\n"
        out DEBUG sending: $ls_command
        printf "$ls_command" $(date +%s) > $env_cmdpipe

        ls_command="[%lu] DEL_SVC_DOWNTIME;$ng_dt_id\n"
        out DEBUG sending: $ls_command
        printf "$ls_command" $(date +%s) > $env_cmdpipe
    
        # pause, then query to see if dt still exists
        sleep $ng_sleepZ

        while [ $flg_command_success -eq 0 ]  && [ $cmd_validate_tries -le $cmd_validate_retries ];
        do
            out DEBUG "Validating removal"
            lql_post_query="GET downtimes\nFilter: id = $ng_dt_id\nColumns: id\n"
            out DEBUG Validation query: $lql_post_query
            lql_result=$(echo -e "$lql_post_query" | unixcat $env_livestatus)
            out DEBUG "Got lql_result: $lql_result"
    
            if [ "$lql_result" != "$ng_dt_id" ]; then
                flg_command_success=1
            else
                cmd_validate_tries=$(( $cmd_validate_tries + 1 ))
                sleep $ng_sleepz
            fi
        done
        cmd_validate_tries=1
        cmd_dt_tries=$(( $cmd_dt_tries + 1 ))
    done

    if [ $flg_command_success -eq 1 ]; then
        out ok "Downtime $ng_dt_id removed\n"
        out debug "Removing $ng_dt_id took $cmd_dt_tries attempts"
    else
        out err "Failed to remove $ng_dt_id after $cmd_dt_tries attempts\n"
        flg_error=1
    fi
}

downtimeType(){
    if [ "$1" == "active" ] || [ "$1" == "pending" ] || [ "$1" == "any" ]; then
        return 0
    else
        return 1
    fi
}


# End of functions

# Now we need to get all the command line parameters.  To match them we need to use a 'if ... fi' rather than a 'case ... esac' as 
# we're looking for different length prefixes.  We also need to support different rules for various parameters.  This takes quite a
# lot of scripting.

# First get switches which need no value
sw_count=$#
if [ $st_debug -gt 0 ]; then
    out DEBUG "Found $sw_count parameters in total"
fi

for switch in "$@"
do
    if [ "${switch}" == "--help" ]; then
        out DEBUG "Found --help"
        out DEBUG "Showing help-basic then quitting"
        flg_help=1
        help-basic
        exit 0

    elif [ "${switch}" == "--Help" ]; then
        out DEBUG "Found --Help"
        out DEBUG "Showing help-detailed then quitting"
        flg_fullhelp=1
        help-detailed
        exit 0

    elif [ "${switch}" == "-v" ]; then
        flg_verbose=1
        out DEBUG "Found -v"

    elif [ "${switch}" == "-V" ]; then
        flg_veryverbose=1
        out DEBUG "Found -V"

    elif [ "${switch}" == "-t" ]; then
        flg_test=1
        out DEBUG "Found -t"
    
    elif [ "${switch}" == "-q" ]; then
        flg_quiet=1
        out DEBUG "Found -q"

    elif [ "${switch}" == "-o" ]; then
        flg_override=1
        out DEBUG "Found -o"

    elif [ "${switch}" == "-k" ]; then
        flg_sticky=1
        out DEBUG "Found -k"
    
    elif [ "${switch}" == "-n" ]; then
        flg_notify=1
        out DEBUG "Found -n"

    elif [ "${switch}" == "--my" ]; then
        flg_my=1
        out DEBUG "Found --my"

    elif [ "${switch}" == "--all" ]; then
        flg_all=1
        out DEBUG "Found --all"

    elif [ "${switch}" == "--force" ]; then
        flg_force=1
        out DEBUG "Found --force"

    elif [ "${switch}" == "--list" ]; then
        flg_list=1
        out DEBUG "Found --list"

    elif [ "${switch}" == "--validate" ]; then
        flg_validate=1
        out DEBUG "Found --validate"

# Now we'll get the rest of the options, validating as we go

    elif [ "${switch:0:10}" == "--defaults" ]; then
        # If specified already handled. Need it here to pass validation.
        pass=1

    elif [ "${switch:0:2}" == "-c" ]; then
        fnd_comment=1
        if [ $flg_comment -eq 1 ]; then
            out DEBUG "Found and ignoring another -c"
        else
            flg_comment=1
            ng_comment=${switch:3}
            out DEBUG "Found -c with value '$ng_comment'"
        fi

    elif [ "${switch:0:2}" == "-b" ]; then
        fnd_begintime=1
        if [ $flg_begintime -eq 1 ]; then
            out DEBUG "Found and ignoring another -b"
        else
            out DEBUG "Found -b with value '${switch:3}'"
            date -d "${switch:3}" &> /dev/null
            if [ $? -eq 0 ]; then
                flg_begintime=4
                ng_begintime=${switch:3}
            else
                flg_begintime=0
                ng_begintime=''
                ng_error="$ng_error\n\t'${switch:3}' is not a valid date / time"
                flg_error=1
            fi
        fi

    elif [ "${switch:0:2}" == "-e" ]; then
        fnd_endtime=1
        if [ $flg_endtime -eq 1 ]; then
            out DEBUG "Found and ignoring another -e"
        else
            out DEBUG "Found -e with value '${switch:3}'"
            date -d "${switch:3}" &> /dev/null
            if [ $? -eq 0 ]; then
                flg_endtime=8
                ng_endtime=${switch:3}
            else
                flg_endtime=0
                ng_endtime=''
                ng_error="$ng_error\n\t'${switch:3}' is not a valid date / time"
                flg_error=1
            fi
        fi

    elif [ "${switch:0:2}" == "-d" ]; then
        fnd_minutes=1
        out DEBUG "Found -d with value '${switch:3}'"
        dcheck=${switch:3}

        if [ ${#ng_minutes} -eq 0 ]; then
            echo ${switch:3} | grep -Po "\d{1,2}$" &> /dev/null
            if [ $? -eq 0 ]; then
                if [ ${#dcheck} -gt 2 ]; then
                    ng_error="$ng_error\n\tInvalid value '${switch:3}' for -d"
                else
                    out DEBUG "Adding ${switch:3} minutes"
                    ng_minutes="${switch:3}"
                    flg_minutes=1
                fi
            else
                ng_error="$ng_error\n\tInvalid value '${switch:3}' for -d"
                flg_error=1
            fi
        else
            out DEBUG "Found and ignoring another -d"
        fi

    elif [ "${switch:0:2}" == "-D" ]; then
        fnd_hours=1
        out DEBUG "Found -D with value '${switch:3}'"
        dcheck=${switch:3}
        if [ ${#ng_hours} -eq 0 ]; then
            echo ${switch:3} | grep -P "\d{1,2}$" &> /dev/null
            if [ $? -eq 0 ]; then
                if [ ${#dcheck} -gt 2 ]; then
                    ng_error="$ng_error\n\tInvalid value '${switch:3}' for -D"
                    flg_error=1
                else
                    out DEBUG "Adding ${switch:3} hours"
                    ng_hours="${switch:3}"
                    flg_hours=2
                fi
            else
                ng_error="$ng_error\n\tInvalid value '${switch:3}' for -D"
                flg_error=1
            fi
        else
            out DEBUG "Found and ignoring another -D"
        fi

    elif [ "${switch:0:2}" == "-h" ]; then
        fnd_hostname=1
        out DEBUG "Found -h with value '${switch:3}'"

        for value in ${switch:3}; do

            htype $value
            returned_htype=$?
            out DEBUG "htype returned $returned_htype"
            if [ $returned_htype -eq 1 ] || [ $flg_override -eq 1 ]; then
                out DEBUG "Type is hostname"
                flg_hostname=1
                if [ ${#ng_hostnames} -gt 0 ]; then
                    isin $value "$ng_hostnames"
                    dupcheck=$?
                    out DEBUG "isin() returned $dupcheck" 
                    if [ $dupcheck -eq 1 ]; then
                        out DEBUG "Adding $value to hostnames"
                        ng_hostnames="$ng_hostnames $value"
                    else
                        out DEBUG "Ignoring duplicate hostname $value"
                    fi
                else
                    out DEBUG "Adding $value to hostnames (first found)"
                    ng_hostnames=$value
                fi
            elif [ $returned_htype -eq 2 ] && [ $flg_override -eq 0 ]; then
                out DEBUG "Type is host template"
                fnd_hosttemplate=1
                if [ $flg_hosttemplate -eq 2 ]; then
                    out DEBUG "Found and ignoring another -h host template"
                else
                    flg_hosttemplate=2
                    ng_hosttemplates=$value
                fi
            else
                ng_error="$ng_error\n\tInvalid value of -h ($value) - code $returned_htype"
                flg_error=1
            fi
        done
        
    elif [ "${switch:0:2}" == "-H" ]; then
        fnd_hostgroup=1
        out DEBUG "Found -H with value '${switch:3}'"
        if [ ${#ng_hostgroups} -gt 0 ]; then
            isin ${switch:3} "$ng_hostgroups"
            dupcheck=$?
            out DEBUG "isin() returned $dupcheck" 
            if [ $dupcheck -eq 1 ]; then
                out DEBUG "Adding ${switch:3} to hostgroups"
                ng_hostgroups="$ng_hostgroups ${switch:3}"
            else
                out DEBUG "Ignoring duplicate hostgroup ${switch:3}"
            fi
        else
            flg_hostgroup=4
            out DEBUG "Adding ${switch:3} to hostgroups (first found)"
            ng_hostgroups=${switch:3}
        fi

    elif [ "${switch:0:2}" == "-s" ]; then
        fnd_service=1
        out DEBUG "Found -s with value '${switch:3}'"
        if [ ${#ng_services} -gt 0 ]; then
            isin ${switch:3} "$ng_services"
            dupcheck=$?
            out DEBUG "isin() returned $dupcheck" 
            if [ $dupcheck -eq 1 ]; then
                out DEBUG "Adding ${switch:3} to services"
                ng_services="$ng_services ${switch:3}"
            else
                out DEBUG "Ignoring duplicate service ${switch:3}"
            fi
        else
            out DEBUG "Adding ${switch:3} to services (first found)"
            ng_services=${switch:3}
            flg_service=1
        fi

    elif [ "${switch:0:2}" == "-x" ]; then
        fnd_rangex=1
        out DEBUG "Found -x with value '${switch:3}'"
        dcheck=${switch:3}
        if [ ${#ng_rangex} -eq 0 ]; then
            echo ${switch:3} | grep -P "\d{1,2}$" &> /dev/null
            if [ $? -eq 0 ]; then
                if [ ${#dcheck} -gt 2 ]; then
                    ng_error="$ng_error\n\tInvalid value '${switch:3}' for -x"
                    flg_error=1
                else
                    out DEBUG "Adding ${switch:3} rangex"
                    ng_rangex="${switch:3}"
                    flg_rangex=1
                fi
            else
                ng_error="$ng_error\n\tInvalid value '${switch:3}' for -x"
                flg_error=1
            fi
        else
            out DEBUG "Found and ignoring another -x"
        fi

    elif [ "${switch:0:2}" == "-y" ]; then
        fnd_rangey=1
        out DEBUG "Found -y with value '${switch:3}'"
        dcheck=${switch:3}
        if [ ${#ng_rangey} -eq 0 ]; then
            echo ${switch:3} | grep -P "\d{1,2}$" &> /dev/null
            if [ $? -eq 0 ]; then
                if [ ${#dcheck} -gt 2 ]; then
                    ng_error="$ng_error\n\tInvalid value '${switch:3}' for -y"
                else
                    out DEBUG "Adding ${switch:3} rangey"
                    ng_rangey="${switch:3}"
                    flg_rangey=2
                fi
            else
                ng_error="$ng_error\n\tInvalid value '${switch:3}' for -y"
            fi
        else
            out DEBUG "Found and ignoring another -y"
        fi

    elif [ "${switch:0:2}" == "-p" ]; then
        fnd_parity=1
        out DEBUG "Found -p with value '${switch:3}'"
        dcheck=${switch:3}
        if [ ${#ng_parity} -eq 0 ]; then
            echo ${switch:3} | grep -P "(odd|even)$" &> /dev/null
            if [ $? -eq 0 ]; then
                out DEBUG "Adding ${switch:3} parity"
                ng_parity="${switch:3}"
                flg_parity=4
            else
                out err "Invalid value '${switch:3}' for -p"
            fi
        else
            out DEBUG "Found and ignoring another -p"
        fi

    elif [ "${switch:0:2}" == "-i" ]; then
        fnd_dt_id=1
        out DEBUG "Found -i with value '${switch:3}'"
        dcheck=${switch:3}
        if [ ${#ng_dt_id} -eq 0 ]; then
            echo ${switch:3} | grep -P "^\d{1,16}$" &> /dev/null
            if [ $? -eq 0 ]; then
                out DEBUG "Adding ${switch:3} dt_id"
                ng_dt_id="${switch:3}"
                flg_dt_id=1
            else
                ng_error="$ng_error\n\tInvalid value '${switch:3}' for -i"
            fi
        else
            out DEBUG "Found and ignoring another -i"
        fi

    elif [ "${switch:0:2}" == "-z" ]; then
        fnd_sleepz=1
        out DEBUG "Found -z with value '${switch:3}'"
        zcheck=${switch:3}
        if [ $flg_sleepz -eq 0 ]; then
            echo ${switch:3} | grep -P "\d{0,}.{0,}\d{0,}$" &> /dev/null
            if [ $? -eq 0 ]; then
                if [ ${#zcheck} -gt 10 ]; then
                    ng_error="$ng_error\n\tInvalid length value '${switch:3}' for -z"
                    flg_error=1
                else
                    out DEBUG "Adding ${switch:3} sleepz"
                    ng_sleepz="${switch:3}"
                    flg_sleepz=1
                fi
            else
                ng_error="$ng_error\n\tInvalid value '${switch:3}' for -z - regex failed"
                flg_error=1
            fi
        else
            out DEBUG "Found and ignoring another -z"
        fi

    elif [ "${switch:0:2}" == "-Z" ]; then
        fnd_sleepz=1
        out DEBUG "Found -Z with value '${switch:3}'"
        Zcheck=${switch:3}
        if [ $flg_sleepZ -eq 0 ]; then
            echo ${switch:3} | grep -P "\d{0,}.{0,}\d{0,}$" &> /dev/null
            if [ $? -eq 0 ]; then
                if [ ${#Zcheck} -gt 10 ]; then
                    ng_error="$ng_error\n\tInvalid length value '${switch:3}' for -Z"
                    flg_error=1
                else
                    out DEBUG "Adding ${switch:3} sleepZ"
                    ng_sleepZ="${switch:3}"
                    flg_sleepZ=1
                fi
            else
                ng_error="$ng_error\n\tInvalid value '${switch:3}' for -Z"
                flg_error=1
            fi
        else
            out DEBUG "Found and ignoring another -Z"
        fi

    elif [ "${switch:0:2}" == "-r" ]; then
        fnd_retry=1
        out DEBUG "Found -r with value '${switch:3}'"
        rcheck=${switch:3}
        if [ $ng_retry -eq 5 ]; then  ## ng_retry is set to 5 as default... smells. "5" should be a var
            echo ${switch:3} | grep -P "\d{0,1}$" &> /dev/null
            if [ $? -eq 0 ]; then
                if [ ${#rcheck} -gt 10 ]; then
                    ng_error="$ng_error\n\tInvalid length value '${switch:3}' for -r"
                    flg_error=1
                else
                    out DEBUG "Adding ${switch:3} command retry"
                    ng_retry="${switch:3}"
                    flg_retry=1
                fi
            else
                ng_error="$ng_error\n\tInvalid value '${switch:3}' for -r - regex failed"
                flg_error=1
            fi
        else
            out DEBUG "Found and ignoring another -r"
        fi

    elif [ "${switch:0:2}" == "-R" ]; then
        fnd_validation_retry=1
        out DEBUG "Found -R with value '${switch:3}'"
        Rcheck=${switch:3}
        if [ $ng_validation_retry -eq 3 ]; then ## this also smells. "3" should be a var
            echo ${switch:3} | grep -P "\d{0,1}$" &> /dev/null
            if [ $? -eq 0 ]; then
                if [ ${#Rcheck} -gt 10 ]; then
                    ng_error="$ng_error\n\tInvalid length value '${switch:3}' for -R"
                    flg_error=1
                else
                    out DEBUG "Adding ${switch:3} validation retry"
                    ng_validation_retry="${switch:3}"
                    flg_validation_retry=1
                fi
            else
                ng_error="$ng_error\n\tInvalid value '${switch:3}' for -R - regex failed"
                flg_error=1
            fi
        else
            out DEBUG "Found and ignoring another -R"
        fi

    elif [ "${switch:0:2}" == "-S" ]; then
        fnd_state=1
        if [ $flg_state -eq 1 ]; then
            out DEBUG "Found and ignoring another -S"
        else
            flg_state=1
            ng_state=${switch:3}
            out DEBUG "Found -S with value '$ng_state'"
        fi

# Query specific parameters

    elif [ "${switch:0:2}" == "-Q" ]; then
        fnd_query_name=1
        if [ $flg_query_name -eq 1 ]; then
            out DEBUG "Found and ignoring another -Q"
        else
            flg_query_name=1
            ng_query_name=${switch:3}
            out DEBUG "Found -Q with value '$ng_query_name'"
        fi

    elif [ "${switch:0:6}" == "--null" ]; then
        fnd_nullquery=1
        if [ $flg_nullquery -eq 1 ]; then
            out DEBUG "Found and ignoring another --null"
        else
            flg_nullquery=1
            ngq_null_query_response=${switch:7}
            out DEBUG "Found --null with value '$ngq_null_query_response'"
        fi

    elif [ "${switch:0:7}" == "--query" ]; then
        fnd_custom_query=1
        if [ $flg_custom_query -eq 1 ]; then
            out DEBUG "Found and ignoring another --query"
        else
            flg_custom_query=1
            ngq_custom_query=${switch:8}
            ngq_custom_query=$(echo $ngq_custom_query | sed 's/\\n/|/g')
            out DEBUG "Found ---query with value '$ngq_custom_query'"
        fi

    elif [ "${switch:0:8}" == "--config" ]; then
        fnd_config_filename=1
        if [ $flg_config_filename -eq 1 ]; then
            out DEBUG "Found and ignoring another --config"
        else
            flg_config_filename=1
            ng_config_filename=${switch:9}
            out DEBUG "Found --config with value '$ng_config_filename'"
        fi

    elif [ "${switch:0:8}" == "--custom" ]; then
        fnd_custom=1
        if [ $flg_custom -eq 1 ]; then
            out DEBUG "Found and ignoring another --custom"
        else
            flg_custom=1
            ng_custom=(${switch:9})
            out DEBUG "Found --custom with value '${ng_custom[@]}'"
            out DEBUG "Found --custom with ${#ng_custom[@]} values"
        fi

# Query and up mode parmaeters

    elif [ "${switch:0:2}" == "-u" ]; then
        fnd_username=1
        if [ $flg_username -eq 1 ]; then
            out DEBUG "Found and ignoring another -u"
        else
            flg_username=1
            ng_username=${switch:3}
            out DEBUG "Found -u with value '$ng_username'"
        fi
    
    elif [ "${switch:0:6}" == "--type" ]; then
        fnd_type=1
        if [ $flg_type -eq 1 ]; then
            out DEBUG "Found and ignoring another --type"
        else
            flg_type=1
            ng_type=${switch:7}
            out DEBUG "Found --type with value '$ng_type'"
            downtimeType $ng_type
            if [ $? -eq 1 ]; then
                ng_error="$ng_error\n\tInvalid value '${switch:7}' for --type"
                flg_error=1
            fi
        fi

    elif [ "$switch" == "--debug=1" ] || [ "$switch" == "--debug=2" ] || [ "$switch" == "--debug=0" ] || 
         [ "$switch" == "--devMode=1" ] || [ "$switch" == "--devMode=2" ] || [ "$switch" == "down" ] ||
         [ "$switch" == "dc" ] || [ "$switch" == "ec" ] || [ "$switch" == "dn" ] || [ "$switch" == "en" ] ||
         [ "$switch" == "disable-checks" ] || [ "$switch" == "enable-checks" ] || [ "$switch" == "disable-notifications" ] ||
         [ "$switch" == "enable-notifications" ] || [ "$switch" == "ack" ] || [ "$switch" == "up" ] || 
         [ "$switch" == "query" ] || [ "$switch" == "rd" ] || [ "$switch" == "remove-downtime" ] ||
         [ "$switch" == "sc" ] || [ "$switch" == "schedule-check" ]
         then
        echo "Catch-all for ok" &> /dev/null

    else
        # Change to previous behaviour where unrecognised parameters where ignored
        ng_error="$ng_error\n\tUnknown parameter $switch"
        flg_error=1
    fi
done

# If 'devkit' is available, load debughacks (fakes simply a socket and pipe for local testing)
if [ -r ./devkit/debughacks.inc ]; then
    source ./devkit/debughacks.inc
fi

out debug "Parmameter processing done"
out debug "Checking access to Livestatus pipe and socket"

# dev note - docker image has pipe and socket at /opt/omd/sites/mva/tmp/run
# Let's make sure that we can write to both the Livestatus socket and the command pipe
err_fatal=0
if [ -p $env_cmdpipe ]; then
    out DEBUG "Command pipe '$env_cmdpipe' exists "
    if [ -w $env_cmdpipe ]; then
        out DEBUG "We can write to the command pipe "
    else
        out ERR "Unable to write to command pipe '$env_cmdpipe' "
        err_fatal=1
    fi
else
    out ERR "Command pipe '$env_cmdpipe' doesn't exist "    
    err_fatal=1
fi

if [ -S $env_livestatus ]; then
    out DEBUG "Livestatus socket '$env_livestatus' exists "
    if [ -w $env_livestatus ]; then
        out DEBUG "We can write to the Livestatus socket "
    else
        out ERR "Unable to write to Livestatus socket '$env_livestatus' "
        err_fatal=1
    fi
else
    out ERR "Livestatus socket '$env_livestatus' doesn't exist "    
    err_fatal=1
fi

if [ $err_fatal -eq 1 ]; then 
    if [ $flg_test -eq 1 ] || [ $devMode -ge 1 ]; then
        out info "Ignoring pipe/socket error(s) in devMode or with -t (running this for real would have failed!)\n"
    else
        out ERR "Failed access checks "
        exit 5
    fi
else
    out debug "Livestatus pipe and socket access ok"
fi

out debug "------------------------------------------------------"
out debug "hostnames           [$ng_hostnames]"
out debug "hosttemplates       [$ng_hosttemplates]"
out debug "hostgroups          [$ng_hostgroups]"
out debug "services            [$ng_services]"
out debug "begin time          [$ng_begintime]"
out debug "end time            [$ng_endtime]"
out debug "minutes             [$ng_minutes]"
out debug "hours               [$ng_hours]"
out debug "comment             [$ng_comment]"
out debug "rangex              [$ng_rangex]"
out debug "rangey              [$ng_rangey]"
out debug "parity              [$ng_parity]"
out debug "user                [$ng_username]"
out debug "filters             [$ng_filters]"
out debug "query name          [$ng_query_name]"
out debug "query               [$ngq_custom_query]"
out debug "null query value    [$ngq_null_query_response]"
out debug "state               [$ng_state]"
out debug "config              [$ng_config_filename]"
out debug "custom values       [${ng_custom[@]}]"
out debug "downtime id         [$ng_dt_id]"
out debug "downtime type       [$ng_type]"
out debug "throttle            [$ng_sleepz]"
out debug "validation pause    [$ng_sleepZ]"
out debug "command retries     [$ng_retry]"
out debug "validation retries  [$ng_validation_retry]"
out debug "Switches:"
out debug "-o override         [$flg_override]"
out debug "-t test             [$flg_test]"
out debug "-k sticky           [$flg_sticky]"
out debug "-n notify           [$flg_notify]"
out debug "-v verbose          [$flg_verbose]"
out debug "-V very verbose     [$flg_veryverbose]"
out debug "-q quiet            [$flg_quiet]"
out debug "--my downtimes      [$flg_my]"
out debug "--list queries      [$flg_list]"
out debug "--validate config   [$flg_validate]"
out debug "------------------------------------------------------"

#if [ $flg_verbose -eq 1 ]; then echo "Got parameters: $@";fi

# Time to do some error checking
# Lets add up the various groups - we can then quickly check what's valid
# This is why we set the "found" values to 1, 2, 4, 8 etc

errchk_times=$(($flg_minutes + $flg_hours + $flg_begintime + $flg_endtime))
errchk_targets=$(($flg_hostname + $flg_hosttemplate + $flg_hostgroup))
errchk_range=$(($flg_rangex + $flg_rangey + $flg_parity))

out debug "Target value     $errchk_targets"
out debug "Times value      $errchk_times"
out debug "Range value      $errchk_range"

# We'll need targets for all modes, so let's start there
out debug "Checking for errors - host targets"

# Values for $errchk_targets (4 valid)
# 1 - one or more hostnames                                         5 - hostname and one or more hostgroups
# 2 - one host template                                             6 - INVALID: one or more hostgroups and host template specified
# 3 - INVALID: hostname and host template specified                 7 - INVALID: one or more hostnames, hostgroups and host template specified
# 4 - one or more hostgroups 

case "$errchk_targets" in
    0)
        # Not all modes require a host target
        if [ $ng_mode != query ] && [ $ng_mode != rmdown ]; then
            ng_error="$ng_error\n\tNo hostnames, hostgroups or host template specified"
            flg_error=1
        fi
        ;;

    3)
        ng_error="$ng_error\n\tOne or more hostnames as well as host template specified"
        flg_error=1
        ;;

    6)
        ng_error="$ng_error\n\tHost template specified as well as one or more hostgroups"
        flg_error=1
        ;;

    7)
        ng_error="$ng_error\n\tHost template specified as well as one or more hostnames and hostgroups"
        flg_error=1
        ;;

    *)
        echo "Catch-all for ok" &> /dev/null
        comb_target=1

esac

# First we'll do some extensive checking of times for 'down' mode

out debug "Checking for errors - times"
if [ $ng_mode = down ] || [ $ng_mode = up ] || [ $ng_mode = scheck ]; then

    # Values for $errchk_times (8 valid):
    # 1 - just minutes, assume start now                                9 -  INVALID: end time and minutes
    # 2 - just hours, assume start now                                  10 - INVALID: end time and hours
    # 3 - minutes and hours, assume start now                           11 - INVALID: end time, minutes and hours
    # 4 - INVALID: begin time only - can't set an end time              12 - begin time and end time - future time frame
    # 5 - minutes and a begin time - future time frame                  13 - INVALID: end time, minutes and begin time
    # 6 - hours and a begin time - future time frame                    14 - INVALID: end time, hours and begin time
    # 7 - minutes, hours and a begin time - future time frame           15 - INVALID: end time, minutes, hours and begin time
    # 8 - end time only, assume start now

    case "$errchk_times" in
        0)
            if [ $ng_mode = down ]; then
                ng_error="$ng_error\n\tNo valid time frame specified"
                flg_error=1
            fi
            ;;

        4)
            if [ $ng_mode != scheck ] && [ $ng_mode != up ] ; then
                ng_error="$ng_error\n\tOnly begin time specified - cannot set and end time"
                flg_error=1
            fi
            ;;
        
        9)
            ng_error="$ng_error\n\tEnd time and minutes specified - ambiguous"
            flg_error=1
            ;;
        
        10)
            ng_error="$ng_error\n\tEnd time and hours specified - ambiguous"
            flg_error=1
            ;;
        
        11)
            ng_error="$ng_error\n\tEnd time, minutes and hours specified - ambiguous"
            flg_error=1
            ;;
        
        13)
            ng_error="$ng_error\n\tEnd time and minutes specified - ambiguous"
            flg_error=1
            ;;
        
        14)
            ng_error="$ng_error\n\tEnd time and hours specified - ambiguous"
            flg_error=1
            ;;
        
        15)
            ng_error="$ng_error\n\tEnd time, minutes and hours specified - ambiguous"
            flg_error=1
            ;;

        *)
            echo "Catch-all for ok" &> /dev/null
    esac

    # Now check that time frame specified is actually sane  (let's not try and end before we start!)
    # We will create the start and end times that we will use later to do this check


    case "$errchk_times" in
        1)      # 1 - just minutes, assume start now
                datefunc now
                if [ $? -eq 0 ]; then 
                    cmd_starttime=$func_time
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                datefunc minutes $ng_minutes
                if [ $? -eq 0 ]; then 
                    cmd_endtime=$(($func_time + $cmd_starttime))
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                # Check what we have is sane
                if [ $cmd_starttime -gt $cmd_endtime ]; then
                    out ERR "Start time is after end time"; exit 1
                else
                    comb_time=1
                fi
                ;;


        2)      #2 - just hours, assume start now
                datefunc now
                if [ $? -eq 0 ]; then 
                    cmd_starttime=$func_time
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                datefunc hours $ng_hours
                if [ $? -eq 0 ]; then 
                    cmd_endtime=$(($func_time + $cmd_starttime))
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                # Check what we have is sane
                if [ $cmd_starttime -gt $cmd_endtime ]; then
                    out ERR "Start time is after end time"; exit 1
                else
                    comb_time=1
                fi
                ;;        

        3)      #3 - minutes and hours, assume start now
                datefunc now
                if [ $? -eq 0 ]; then 
                    cmd_starttime=$func_time
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                datefunc minutes $ng_minutes
                if [ $? -eq 0 ]; then 
                    cmd_endtime=$(($func_time + $cmd_starttime))
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                datefunc hours $ng_hours
                if [ $? -eq 0 ]; then 
                    cmd_endtime=$(($func_time + $cmd_endtime))
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                # Check what we have is sane
                if [ $cmd_starttime -gt $cmd_endtime ]; then
                    out ERR "Start time is after end time"; exit 1
                else
                    comb_time=1
                fi
                ;;

        4)      #4 - begin only, valid for scheck and up modes
                if [ $ng_mode == scheck ] || [ $ng_mode == up ] ; then
                    datefunc absolute "$ng_begintime"
                    if [ $? -eq 0 ]; then 
                        cmd_starttime=$func_time
                    else
                        out ERR "Something has gone horribly wrong"; exit 1
                    fi
                fi
                ;;

        5)      #5 - minutes and a begin time - future time frame

                datefunc absolute "$ng_begintime"
                if [ $? -eq 0 ]; then 
                    cmd_starttime=$func_time
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                datefunc minutes $ng_minutes
                if [ $? -eq 0 ]; then 
                    cmd_endtime=$(($func_time + $cmd_starttime))
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                # Check what we have is sane
                if [ $cmd_starttime -gt $cmd_endtime ]; then
                    out ERR "Start time is after end time"; exit 1
                else
                    comb_time=1
                fi
                ;;


        6)      #6 - hours and a begin time - future time frame

                datefunc absolute "$ng_begintime"
                if [ $? -eq 0 ]; then 
                    cmd_starttime=$func_time
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                datefunc hours $ng_hours
                if [ $? -eq 0 ]; then 
                    cmd_endtime=$(($func_time + $cmd_starttime))
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                # Check what we have is sane
                if [ $cmd_starttime -gt $cmd_endtime ]; then
                    out ERR "Start time is after end time"; exit 1
                else
                    comb_time=1
                fi
                ;;

        7)      #7 - minutes, hours and a begin time - future time frame

                    datefunc absolute "$ng_begintime"
                if [ $? -eq 0 ]; then 
                    cmd_starttime=$func_time
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                datefunc minutes $ng_minutes
                if [ $? -eq 0 ]; then 
                    cmd_endtime=$(($func_time + $cmd_starttime))
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                datefunc hours $ng_hours
                if [ $? -eq 0 ]; then 
                    cmd_endtime=$(($func_time + $cmd_endtime))
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                # Check what we have is sane
                if [ $cmd_starttime -gt $cmd_endtime ]; then
                    out ERR "Start time is after end time"; exit 1
                else
                    comb_time=1
                fi
                ;;

        8)      #8 - end time only, assume start now

                datefunc now
                if [ $? -eq 0 ]; then 
                    cmd_starttime=$func_time
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                datefunc absolute "$ng_endtime"
                if [ $? -eq 0 ]; then 
                    cmd_endtime=$func_time
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                # Check what we have is sane
                if [ $cmd_starttime -gt $cmd_endtime ]; then
                    out ERR "Start time is after end time"; exit 1
                else
                    comb_time=1
                fi
                ;;

        12)     #12 - begin time and end time - future time frame
                datefunc absolute "$ng_begintime"
                if [ $? -eq 0 ]; then 
                    cmd_starttime=$func_time
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                datefunc absolute "$ng_endtime"
                if [ $? -eq 0 ]; then 
                    cmd_endtime=$func_time
                else
                    out ERR "Something has gone horribly wrong"; exit 1
                fi
                # Check what we have is sane
                if [ $cmd_starttime -gt $cmd_endtime ]; then
                    out ERR "Start time is after end time"; exit 1
                else
                    comb_time=1
                fi
                ;;
    esac

    if [ $ng_mode = scheck ] && [ "$ng_begintime" != "" ]; then
        datefunc absolute "$ng_begintime"
        if [ $? -eq 0 ]; then 
            cmd_starttime=$func_time
        else
            out ERR "Something has gone horribly wrong"; exit 1
        fi
    fi

    if [ $ng_mode = down ] || [ $ng_mode = scheck ]; then
        datefunc now
        if [ $? -eq 0 ]; then
            now_time=$func_time
        else
            out ERR "Something has gone horribly wrong"; exit 1
        fi
        if [ $cmd_starttime -lt $now_time ]; then
            out ERR "Start time is in the past"; exit 1
        fi
    fi

    out debug "Start: $cmd_starttime   End: $cmd_endtime"
    datefunc unix $cmd_starttime
    out debug "Start: $func_time"
    datefunc unix $cmd_endtime
    out debug "End:   $func_time"

elif [ $ng_mode == query ]; then

    out debug Checking times in query context

    if [ $flg_begintime -gt 0 ]; then
        datefunc absolute "$ng_begintime"
        if [ $? -eq 0 ]; then 
            cmd_starttime=$func_time
        else
            out ERR "Something has gone horribly wrong"; exit 1
        fi
    fi

    if [ $fnd_endtime -gt 0 ]; then
        datefunc absolute "$ng_endtime"
        if [ $? -eq 0 ]; then 
            cmd_endtime=$func_time
        else
            out ERR "Something has gone horribly wrong"; exit 1
        fi
    fi

    if [ $fnd_hours -gt 0 ]; then
        ng_error="$ng_error\n\tHours is not valid in query mode"
        flg_error=1
    fi

    if [ $fnd_minutes -gt 0 ]; then
        ng_error="$ng_error\n\tMinutes is not valid in query mode"
        flg_error=1
    fi

    out debug "Start time if any is $cmd_starttime"
    out debug "End time if any is $cmd_endtime"

fi

# Values for $errchk_range (2 valid)
# 1 - INVALID: Only start of range specified                        5 - INVALID: Only start and parity of range specified
# 2 - INVALID: Only end of range specified                          6 - INVALID: Only end and parity of range specified
# 3 - Start and end of range specified                              7 - Start, end and parity of range specified
# 4 - INVALID: Only parity of range specified 

out debug "Checking for errors - range"
if [ $errchk_range -gt 0 ] && [ $errchk_targets -ne 2 ]; then
    ng_error="$ng_error\n\tRange specified without host template, or hostname(s) and/or hostgroup(s) specified as well"
    flg_error=1
fi

case "$errchk_range" in
    0)
        comb_range=0
        ;;
    1)
        ng_error="$ng_error\n\tOnly start of range specified"
        flg_error=1
        ;;

    2)
        ng_error="$ng_error\n\tOnly end of range specified"
        flg_error=1
        ;;

    4)
        ng_error="$ng_error\n\tOnly parity of range specified"
        flg_error=1
        ;;

    5)
        ng_error="$ng_error\n\tOnly start and parity of range specified"
        flg_error=1
        ;;

    6)
        ng_error="$ng_error\n\tOnly end and parity of range specified"
        flg_error=1
        ;;

    *)
        echo "Catch-all for ok" &> /dev/null            #  This isn't handling no range specified
        comb_range=1
        ;;
esac

# Let create the range numbers as $ng_range if we've got a valid combination
if [ $comb_range -eq 1 ]; then
    if [ $ng_rangex -lt $ng_rangey ]; then
        out DEBUG "Valid range parameter combination found"
        # Is the first number odd or even?
        rxp=$(($ng_rangex % 2))
        if [ "$rxp" -ne "0" ]
        then
            ng_rangeXparity='odd'
        else
            ng_rangeXparity='even'
        fi
        out DEBUG "$ng_rangex is an $ng_rangeXparity number"

        # Generate  the list based on the parity of x and the parity if specified
        if [ $errchk_range -eq 3 ]; then
            cmd_range=$(for r in `seq $ng_rangex $ng_rangey`; do printf %.2d $r;echo;done)
        elif [ $errchk_range -eq 7 ]; then
            if [ "$ng_rangeXparity" = "$ng_parity" ]; then
                cmd_range=$(for r in `seq $ng_rangex 2 $ng_rangey`; do printf %.2d $r;echo;done)
            else
                ng_rangex=$(( $ng_rangex + 1 ))
                cmd_range=$(for r in `seq $ng_rangex 2 $ng_rangey`; do printf %.2d $r;echo;done)
            fi
        else
            out ERR "We should not be trying to set a range!"; exit 3
        fi
    else
        ng_error="$ng_error\n\tRange start is greater than range end"
        flg_error=1
        comb_range=0
    fi
fi

if [ $comb_target -eq 1 ]; then
    # Target combinations are OK, and we've checked other generic parmaters. Lets build target list

    if [ $errchk_targets -eq 1 ] || [ $errchk_targets -eq 4 ] || [ $errchk_targets -eq 5 ]; then

        out DEBUG "Building target list from hostnames and/or hostgroups"
        cmd_targets=$ng_hostnames
        if [ ${#ng_hostgroups} -gt 0 ]; then
            for group in $ng_hostgroups; do 
                out DEBUG "Starting getHostsbygroup $group"
                getHostsbygroup $group
                out DEBUG "getHostsbtgroup returned: $hostgroup_hosts"
                if [ ${#cmd_targets} -gt 0 ]; then
                    cmd_targets="$cmd_targets $hostgroup_hosts"
                else
                    cmd_targets=$hostgroup_hosts
                fi
            done
        fi
        
        # If we've got hostgroups involved, remove any duplicate hostnames from targets
        if [ $errchk_targets -eq 4 ] || [ $errchk_targets -eq 5 ]; then
            dedupe $cmd_targets
            out DEBUG "Removed $? duplicate hostname(s)"
            cmd_targets="$dedupe_result"

        fi

    elif [ $errchk_targets -eq 2 ] && [ $comb_range -eq 1 ]; then

        out DEBUG "Building target list from host template and range"
        cmd_targets=''
        for number in $cmd_range
        do
            if [ ${#cmd_targets} -gt 0 ]; then
                cmd_targets="$cmd_targets $ng_hosttemplates$number"
            else
                cmd_targets=$ng_hosttemplates$number
            fi
        done

    else
        flg_error=1
        ng_error="$ng_error\n\tCan't build hostnames list from template without a valid range"
    fi
    out DEBUG "Targets: $cmd_targets"
fi

# Purley for consistency later, set some more variables; all the values in the command and validate
# section should be prefixed with cmd_ to ensure we're using final values
cmd_services=$ng_services
cmd_comment=$ng_comment
cmd_user=$USER
cmd_retries=$ng_retry                       # number of times to try sending the command
cmd_validate_retries=$ng_validation_retry   # number of times to try and validate after each command try
cmd_sticky=$flg_sticky
cmd_notify=$flg_notify
cmd_persistent=1
if [ $cmd_user == root ]; then
    cmd_user=$SUDO_USER
fi

# That's the end of generic error checking - we'll output any errors after mode specific error checking
out debug "Finished checking for generic errors"
out debug "------------------------------------------------------"


# Any references to time are only valid for these modes
if [ $ng_mode != down ] && [ $ng_mode != up ] && [ $ng_mode != query ] && [ $ng_mode != scheck ]; then
    if [ $errchk_times -gt 0 ]; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tTimes or durations are not valid for $ng_mode mode")
    fi
fi

if [ "$ng_mode" != "query" ] && [ "$ng_mode" != "rmdown" ] && [ "$ng_mode" != "up" ]; then  
                # this should cover all use cases (send and validate a command) 
                # except query, rmdown and up modes which are handled seperately

    # Mode specific error checking - all but query mode

    # Do we have a comment? down and ack modes only
    if [ "$ng_mode" == "down" ] || [ "$ng_mode" == "ack" ]; then
        if [ $flg_comment -eq 0 ] ; then
            flg_error=1
            ng_error="$ng_error\n\tNo comment provided"
        fi
    else
        if [ $flg_comment -eq 1 ] ; then
            flg_error=1
            ng_error="$ng_error\n\tComment not valid in $ng_mode mode"
        fi
    fi

    # Error if query, up or rmdown mode specfic parameters have been specified
    noQueryParams
    noUpParams
    noRmdownParams

    # -u only for up and query modes
    if [ $ng_mode != up ] && [ $ng_mode != query ]; then
        if [ $flg_username -eq 1 ]; then
            flg_error=1
            ng_error="$ng_error\n\t-u not valid in $ng_mode mode"
        fi
    fi

    # Error if ack mode specfic parameters have been specified
    if [ $ng_mode != ack ]; then
        noAckParams
    fi

    # ack mode checks
    if [ $ng_mode == ack ]; then
        out DEBUG "Beginning ACK mode checks"
        if [ ${#cmd_targets} -eq 0 ] && [ ${#cmd_services} -eq 0 ]; then
            flg_error=1
            ng_error="$ng_error\n\tNothing to acknowledge"
        fi

        # If generic errors or specific errors were found, report them and exit
        # if [ $flg_error -eq 1 ]; then out err "$ng_error"; exit 1; fi

        out DEBUG "Finished error checking in ACK mode"
    fi

    # scheck mode checks
    if [ $ng_mode == scheck ]; then
        out DEBUG "Beginning SC mode checks"
        if [ $flg_force -eq 0 ]; then
            scheck_host_command="SCHEDULE_HOST_CHECK"
            scheck_service_command="SCHEDULE_SVC_CHECK"
            if [ $flg_all -eq 1 ]; then
                scheck_host_command="SCHEDULE_HOST_SVC_CHECKS"
            fi
        else
            scheck_host_command="SCHEDULE_FORCED_HOST_CHECK"
            scheck_service_command="SCHEDULE_FORCED_SVC_CHECK"
            if [ $flg_all -eq 1 ]; then
                scheck_host_command="SCHEDULE_FORCED_HOST_SVC_CHECKS"
            fi
        fi
        out DEBUG "scheck_host_command is\t$scheck_host_command"
        out DEBUG "scheck_service_command is\t$scheck_service_command"
        if [ $flg_service -eq 1 ] && [ $flg_all -eq 1 ]; then
            flg_error=1
            ng_error="$ng_error\n\tCan't use --all when specifying services"
        fi

        # in scheck mode, only an offset or absolute begin time is vaild
        if [ $errchk_times -eq 2 ] || [ $errchk_times -eq 3 ] || [ $errchk_times -eq 1 ]; then
            out debug "Scheduling check for end time"
            cmd_schecktime=$cmd_endtime
        elif [ $errchk_times -eq 0 ]; then
            out DEBUG "Scheduling check for 10 seconds in the future"
            cmd_schecktime=$(date -d "10 seconds" +%s)
        elif [ $errchk_times -eq 4 ]; then
            out DEBUG "Scheduling check for begin time"
            cmd_schecktime=$cmd_starttime
        else
            out debug "Time checks for scheck mode FAILED"
            flg_error=1
            ng_error=$(echo -e "$ng_error\n\tOnly begin time or durations (as an offset from now) is valid for $ng_mode mode")
        fi
        out DEBUG "Finished error checking in SC mode"
    fi

    if [ $ng_mode != scheck ]; then
        noScheckParams
    fi

    # If generic errors or specific errors were found, report them and exit
    if [ $flg_error -eq 1 ]; then out err "$ng_error"; exit 1; fi

    # Looking good, output some info if we're in either verbose modes
    if [ $flg_verbose -eq 1 ] || [ $flg_veryverbose -eq 1 ]; then
        out INFO "The following values will be used for mode $ng_mode:\n"
        out info "Targets:\t$cmd_targets\n"
        if [ $flg_service -gt 0 ]; then
            out info "Services:\t$cmd_services\n"
        fi
        if [ $flg_begintime -gt 0 ]; then
            datefunc unix $cmd_starttime
            out info "Start:\t\t$cmd_starttime ($func_time)\n"
            datefunc unix $cmd_endtime
            out info "End:\t\t$cmd_endtime ($func_time)\n"
        fi
        out info "Comment:\t$cmd_comment\n"
        out info "User:\t\t$cmd_user\n"
    fi

    #if [ $devMode -gt 0 ]; then 
    #    out ok "In devMode $devMode we don't try and validate the commands\n\n"
#---------------------------------------------------------------------

    # Experimental - tries to predict execution time (badly so far)
    if [ -r schedule.inc ]; then
        source schedule.inc
        schedule
    fi
    # To aid the schedule.inc code, record start time of command processing
    # (might as well do this unconditionally)
    datefunc "now"
    ng_down_start=$func_time
    out DEBUG "Starting command process at $ng_down_start"


    for targethost in $cmd_targets; do
        if [ $flg_service -eq 0 ] && [ "$cmd_services" == "" ]; then
            # a bit of a fudge, but it almost halves the amount of code needed
            # This works because $flg_service is 0 and so the following condition
            # checks always go to _HOST_ command sections
            cmd_services='at_least_one_loop_for_host_only_downtimes'
        fi
        for service in $cmd_services; do
            ls_command=undefined
            if [ $ng_mode == down ]; then

                if [ $flg_service -eq 1 ]; then
                    ls_command="[%lu] SCHEDULE_SVC_DOWNTIME;$targethost;$service;$cmd_starttime;$cmd_endtime;1;0;0;$cmd_user;$cmd_comment\n"
                    lql_pre_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nColumns: host_name\n"
                    lql_post_query="GET downtimes\nFilter: author = $cmd_user\nFilter: host_name = $targethost\nFilter: end_time = $cmd_endtime\nFilter: start_time = $cmd_starttime\nFilter: service_description = $service\nColumns: id\n"
                else
                    ls_command="[%lu] SCHEDULE_HOST_DOWNTIME;$targethost;$cmd_starttime;$cmd_endtime;1;0;0;$cmd_user;$cmd_comment\n"
                    lql_pre_query="GET hosts\nFilter: name = $targethost\nColumns: name\n"
                    lql_post_query="GET downtimes\nFilter: author = $cmd_user\nFilter: host_name = $targethost\nFilter: end_time = $cmd_endtime\nFilter: start_time = $cmd_starttime\nColumns: id\n"
                fi

            elif [ $ng_mode == ack ]; then

                if [ $flg_service -eq 1 ]; then
                    ls_command="[%lu] ACKNOWLEDGE_SVC_PROBLEM;$targethost;$service;$cmd_sticky;$cmd_notify;$cmd_persistent;$cmd_user;$cmd_comment\n"
                    lql_pre_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nFilter: state >= 1\nColumns: host_name\n"
                    lql_post_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nFilter: state >= 1\nFilter: acknowledged = 1\nColumns: acknowledgement_type\n"
                else
                    ls_command="[%lu] ACKNOWLEDGE_HOST_PROBLEM;$targethost;$cmd_sticky;$cmd_notify;$cmd_persistent;$cmd_user;$cmd_comment\n"
                    lql_pre_query="GET hosts\nFilter: name = $targethost\nFilter: state >= 1\nColumns: name\n"
                    lql_post_query="GET hosts\nFilter: name = $targethost\nFilter: state >= 1\nFilter: acknowledged = 1\nColumns: acknowledgement_type\n"
                fi

            elif [ $ng_mode == discheck ]; then

                if [ $flg_service -eq 1 ]; then
                    ls_command="[%lu] DISABLE_SVC_CHECK;$targethost;$service\n"
                    lql_pre_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nColumns: host_name\n"
                    lql_post_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nFilter: checks_enabled = 0\nColumns: checks_enabled\n"
                else
                    ls_command="[%lu] DISABLE_HOST_CHECK;$targethost\n"
                    lql_pre_query="GET hosts\nFilter: name = $targethost\nColumns: name\n"
                    lql_post_query="GET hosts\nFilter: name = $targethost\nFilter: state >= 1\nFilter: checks_enabled = 0\nColumns: checks_enabled\n"
                fi

            elif [ $ng_mode == encheck ]; then

                if [ $flg_service -eq 1 ]; then
                    ls_command="[%lu] ENABLE_SVC_CHECK;$targethost;$service\n"
                    lql_pre_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nColumns: host_name\n"
                    lql_post_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nFilter: checks_enabled = 1\nColumns: checks_enabled\n"
                else
                    ls_command="[%lu] ENABLE_HOST_CHECK;$targethost\n"
                    lql_pre_query="GET hosts\nFilter: name = $targethost\nColumns: name\n"
                    lql_post_query="GET hosts\nFilter: name = $targethost\nFilter: state >= 1\nFilter: checks_enabled = 1\nColumns: checks_enabled\n"
                fi

            elif [ $ng_mode == disnotif ]; then

                if [ $flg_service -eq 1 ]; then
                    ls_command="[%lu] DISABLE_SVC_NOTIFICATIONS;$targethost;$service\n"
                    lql_pre_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nColumns: host_name\n"
                    lql_post_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nFilter: notifications_enabled = 0\nColumns: notifications_enabled\n"
                else
                    ls_command="[%lu] DISABLE_HOST_NOTIFICATIONS;$targethost\n"
                    lql_pre_query="GET hosts\nFilter: name = $targethost\nColumns: name\n"
                    lql_post_query="GET hosts\nFilter: name = $targethost\nFilter: state >= 1\nFilter: notifications_enabled = 0\nColumns: notifications_enabled\n"
                fi

            elif [ $ng_mode == ennotif ]; then

                if [ $flg_service -eq 1 ]; then
                    ls_command="[%lu] ENABLE_SVC_NOTIFICATIONS;$targethost;$service\n"
                    lql_pre_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nColumns: host_name\n"
                    lql_post_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nFilter: notifications_enabled = 1\nColumns: notifications_enabled\n"
                else
                    ls_command="[%lu] ENABLE_HOST_NOTIFICATIONS;$targethost\n"
                    lql_pre_query="GET hosts\nFilter: name = $targethost\nColumns: name\n"
                    lql_post_query="GET hosts\nFilter: name = $targethost\nFilter: state >= 1\nFilter: notifications_enabled = 1\nColumns: notifications_enabled\n"
                fi

            elif [ $ng_mode == scheck ]; then

                if [ $flg_service -eq 1 ]; then
                    ls_command="[%lu] $scheck_service_command;$targethost;$service;$cmd_schecktime\n"
                    lql_pre_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nColumns: host_name\n"
                    lql_post_query="GET services\nFilter: host_name = $targethost\nFilter: description = $service\nColumns: next_check\n"
                else
                    ls_command="[%lu] $scheck_host_command;$targethost;$cmd_schecktime\n"
                    lql_pre_query="GET hosts\nFilter: name = $targethost\nColumns: name\n"
                    lql_post_query="GET hosts\nFilter: name = $targethost\nColumns: next_check\n"
                fi

            fi

            if [ "$ls_command" == "undefined" ]; then
                out info "Mode $ng_mode not implemented yet, sorry\n"
                exit 21
            fi

            if [ $flg_veryverbose -eq 1 ]; then out info "$ls_command" ;fi
            out debug "Pre-query:\n$lql_pre_query"
            if [ $flg_veryverbose -eq 0 ]; then out debug "$ls_command"; fi
            out debug "Post-query:\n$lql_post_query"
            if [ $flg_test -eq 0 ] && [ $devMode -eq 0 ]; then
                flg_error=0
                # Send the pre_query and see if what we're looking to affect exists
                # if it does
                lql_pre_result=$(echo -e "$lql_pre_query" | unixcat $env_livestatus)
                out DEBUG "Pre-query result: $lql_pre_result"
                if [ "$lql_pre_result" == "$targethost" ]; then

                    # Counters and flags for retry logic
                    cmd_dt_tries=1               # number of times we've tried sending the command
                    cmd_validate_tries=1         # number of times we've tried to validate, afer each command try
                    flg_command_success=0        # set to 1 once we've successfully validated the command

                    # For validating schedule check we need the value of the current result of the post query
                    # and also check if the time we asked for is after the existing next check time,
                    # unless --force is used
                    if [ $ng_mode = scheck ]; then
                        if [ $flg_force -eq 0 ]; then
                            ng_next_check=$(echo -e "$lql_post_query" | unixcat $env_livestatus)
                            out DEBUG "Next check current value: $ng_next_check"
                            if [ $cmd_schecktime -gt $ng_next_check ]; then
                                flg_command_success=1
                                datefunc unix $ng_next_check
                                out ok "Sooner check already scheduled for: $func_time\n"
                            fi
                        else
                            out DEBUG "Not checking next scheduled check, --force used"
                        fi
                    fi

                    while [ $flg_command_success -eq 0 ]  && [ $cmd_dt_tries -le $cmd_retries ];
                    do
                        out DEBUG "Sending command to $env_cmdpipe, try $cmd_dt_tries"
                        printf "$ls_command" $(date +%s) > $env_cmdpipe
                        if [ $flg_quiet -eq 0 ]; then printf "*" ; back="$back\b"; fi    # Bit of a hack for now
                        sleep $ng_sleepZ
                        while [ $flg_command_success -eq 0 ]  && [ $cmd_validate_tries -le $cmd_validate_retries ];
                        do
                            out DEBUG "Validating via $env_livestatus, try $cmd_validate_tries"
                            lql_post_result=$(echo -e "$lql_post_query" | unixcat $env_livestatus)
                            out DEBUG "Post-query result: $lql_post_result"

                            # Generic validation - pass if post query returned anything
                            # Works for most cases if the post query result not being null can be an indication of success
                            if [ $ng_mode != scheck ]; then
                                if [ ${#lql_post_result} -gt 0 ]; then
                                    if [ $flg_quiet -eq 0 ]; then
                                        printf "$back"    # Bit of a hack for now
                                        if [ $flg_service -eq 0 ]; then
                                            out ok "Success: $targethost - result $lql_post_result\n"
                                        else
                                            out ok "Success: $service on $targethost - result $lql_post_result\n"
                                        fi
                                        flg_command_success=1
                                    else
                                        echo -e $lql_post_result
                                        flg_command_success=1
                                    fi
                                else
                                    if [ $flg_quiet -eq 0 ]; then printf "." ; back="$back\b"; fi    # Bit of a hack for now
                                    cmd_validate_tries=$(( $cmd_validate_tries + 1 ))
                                    sleep $ng_sleepz 
                                fi
                            fi

                            # Schedule service validation
                            if [ $ng_mode = scheck ]; then
                                # Has next check been scheduled sooner than it was? If so all good
                                if [ $flg_all -eq 1 ]; then
                                    # Can't validate when scheduling ALL checks on a host, so just pass
                                    flg_command_success=1
                                    if [ $flg_quiet -eq 0 ]; then
                                        printf "$back"
                                        out info "OK: Can't validate when scheduling ALL checks on host(s)\n"
                                    else
                                        echo -e "OK"
                                    fi
                                elif [ $flg_force -eq 1 ]; then
                                    # --force can be used when specifying a date/time so validation
                                    # of next check time doesn't make sense
                                    flg_command_success=1
                                    datefunc unix $lql_post_result
                                    if [ $flg_quiet -eq 0 ]; then
                                        printf "$back"
                                        out info "OK: Next check time is $func_time\n"
                                    else
                                        echo -e "$func_time"
                                    fi
                                else
                                    # You would think that -gt would make more sense here. race But condition.
                                    if [ $ng_next_check -ne $lql_post_result ]; then
                                        flg_command_success=1
                                        datefunc unix $lql_post_result
                                        if [ $flg_quiet -eq 0 ]; then
                                            printf "$back"
                                            out ok "Success - new check time is $func_time\n"
                                        else
                                            echo -e "$func_time"
                                        fi
                                    else
                                        if [ $flg_quiet -eq 0 ]; then printf "." ; back="$back\b"; fi    # Bit of a hack for now
                                        cmd_validate_tries=$(( $cmd_validate_tries + 1 ))
                                        sleep $ng_sleepz
                                    fi
                                fi
                            fi
                        done
                        cmd_validate_tries=1
                        cmd_dt_tries=$(( $cmd_dt_tries + 1 ))
                    done

                    if [ $flg_command_success -eq 0 ]; then
                        cmd_dt_tries=$(( $cmd_dt_tries - 1 ))
                        if [ $flg_quiet -eq 0 ]; then
                            printf "$back"    # Bit of a hack for now
                            if [ $flg_service -eq 0 ]; then
                                out err "Failed: $targethost - after $cmd_dt_tries attempts\n"
                                flg_error=1
                            else
                                out err "Failed: $service on $targethost - after $cmd_dt_tries attempts\n"
                                flg_error=1
                            fi
                        else
                            out err -1
                            flg_error=1
                        fi
                    fi
                    # end some retry logic here
                else
                    out err "Trying to send command for invalid host and/or service: $service $targethost"
                    flg_error=1
                    #exit 1
                fi
            else
                out debug "In devMode $devMode, or with -t we don't try and send the commands\n"
                out DEBUG "$ls_command"
            fi
        done
    done

    # Record the end time of execution, again to support schedule.inc
    datefunc "now"
    ng_down_finish=$func_time
    out DEBUG "End of command process"
    ng_down_time=$(( $ng_down_finish - $ng_down_start ))
    out DEBUG "Execution took $ng_down_time seconds"
    if [ $flg_quiet -eq 0 ]; then
        out ok "Execution took $ng_down_time seconds\n"
    fi
    if [ $flg_error -eq 1 ]; then
        exit 1
    else
        exit 0
    fi

#   End of command mode code
#------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------
# Starting error checking in query mode

elif [ "$ng_mode" == "query" ]; then

    out DEBUG "query mode - Needs a query and other parameters\n"
    
    if [ $flg_quiet -eq 1 ] ; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tQuiet is not valid in $ng_mode mode")
    fi

    # Error if there are multiple hosts/services, or Up or Rmdown parameters are specified
    noMultipleHostsServices
    noUpParams
    noRmdownParams

#   Check that we have a max of 5 custom values
    if [ ${#ng_custom[@]} -gt 5 ]; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tOnly 5 custom values are allowed, found ${#ng_custom[@]}")
    fi

#   Check if config file is provided or use default
    if [ $flg_config_filename -gt 0 ]; then
        if [ -f $ng_config_filename ]; then
            out debug $ng_config_filename exists
            ngq_filename=$ng_config_filename
        else
            flg_error=1
            ng_error=$(echo -e "$ng_error\n\tConfig file not found: $ng_config_filename")
        fi
    fi

#   Check we've got a query name, unless with --list or --validate
    if [ $fnd_query_name -eq 0 ] ; then
        if [ $flg_list -gt 0 ] || [ $flg_validate -gt 0 ] || [ $flg_custom_query -gt 0 ]; then
            out debug "Query name not needed"
        else        
            flg_error=1
            ng_error=$(echo -e "$ng_error\n\tRequired query name not found")
        fi
    fi

#   Check that only one of -Q or --query has been specified
    if [ $fnd_query_name -gt 0 ] && [ $flg_custom_query -gt 0 ]; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tCan't specify -Q and --query")
    fi

    if [ $fnd_begintime -ne 0 ] || [ $fnd_comment -ne 0 ] || [ $fnd_config_filename -ne 0 ] ||
    [ $fnd_custom -ne 0 ] || [ $fnd_endtime -ne 0 ] || [ $fnd_hostgroup -ne 0 ] || [ $fnd_hostname -ne 0 ] ||
    [ $fnd_hosttemplate -ne 0 ] || [ $fnd_hours -ne 0 ] || [ $fnd_minutes -ne 0 ] || [ $fnd_notify -ne 0 ] ||
    [ $fnd_parity -ne 0 ] || [ $fnd_rangex -ne 0 ] || [ $fnd_rangey -ne 0 ] || [ $fnd_service -ne 0 ] ||
    [ $fnd_state -ne 0 ] || [ $fnd_sticky -ne 0 ] || [ $fnd_username -ne 0 ] || [ $flg_my -eq 1 ] ||
    [ $flg_type -eq 1 ] || [ $flg_all -ne 0 ] || [ $fnd_dt_id -ne 0 ] || [ $flg_override -ne 0 ] ||
    [ $flg_quiet -eq 1 ] && [ $flg_custom_query -gt 0 ]; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tIn query mode and using --query, no other parameters are valid")
    fi

#   Validate what if any state we've got and convert OK|ok to 0, WARN|warn to 1, etc

    if [ $fnd_state -gt 0 ]; then
        out DEBUG Checking value of $ng_state
        case $ng_state in
            ok|OK|Ok|0)
                ng_state=0
                out debug Setting state to $ng_state
                ;;
            warn|WARN|Warn|1)
                ng_state=1
                out debug Setting state to $ng_state
                ;;
            crit|critical|CRIT|CRITICAL|Critical|2)
                ng_state=2
                out debug Setting state to $ng_state
                ;;
            unknown|UNKNOWN|Unknown|unk|UNK|3)
                ng_state=3
                out debug Setting state to $ng_state
                ;;
            *)
                flg_error=1
                ng_error=$(echo -e "$ng_error\n\tInvalid value '$ng_state' for parameter state")
        esac
    else
        ng_state=-1
    fi

    # If generic errors or specific errors were found, report them and exit
    if [ $flg_error -eq 1 ]; then out err "$ng_error"; exit 1; fi


    # Start of query mode
    # --------------------------------------------------------------------------------------


    # List of LQL keywords to check when validating
    # Add to it if you have valid LQL that fails to pass
    LQLprefix=(
        GET
        Filter
        Columns
        Or
        And
        Negate
        Separators
        OutputFormat
        Stats
        Limit
        ColumnHeaders
    )

    # List of keywords used in the ngctlq.conf file
    ngctlq_conf_prefix=(
        begin
        description
        author
        end
    )

    # Variables used in the configuration file
    # These are replaced with values specified to ngctl
    ngVariables=(
        NG_HOST_NAME
        NG_HOSTGROUP
        NG_SERVICE
        NG_STATE
        NG_CURRENT_USER
        NG_USER
        NG_UNIXTIME_B
        NG_UNIXTIME_E
        NG_CUSTOM_1
        NG_CUSTOM_2
        NG_CUSTOM_3
        NG_CUSTOM_4
        NG_CUSTOM_5
    )

    # Set default values to 'not_set' so we can test later
    ngq_host_name=not_set
    ngq_hostgroup=not_set
    ngq_service=not_set
    ngq_state=not_set
    ngq_current_user=not_set
    ngq_user=not_set
    ngq_unixtime_b=not_set
    ngq_unixtime_e=not_set
    ngq_custom_1=not_set
    ngq_custom_2=not_set
    ngq_custom_3=not_set
    ngq_custom_4=not_set
    ngq_custom_5=not_set


    # This is where we set the values used in the ngValues array from the gathered parameters

    section=$ng_query_name

    if [ ${#ng_hostnames} -gt 0 ]; then
        ngq_host_name=$ng_hostnames
    fi

    if [ ${#ng_hostgroups} -gt 0 ]; then
        ngq_hostgroup=$ng_hostgroups
    fi

    if [ ${#cmd_services} -gt 0 ]; then
        ngq_service=$cmd_services
    fi

    if [ $ng_state -ge 0 ]; then
        ngq_state=$ng_state
    fi

    ngq_current_user=$cmd_user

    if [ ${#ng_username} -gt 0 ]; then
        ngq_user=$ng_username
    fi

    if [ $cmd_starttime -gt 0 ]; then
        ngq_unixtime_b=$cmd_starttime
    fi

    if [ $cmd_endtime -gt 0 ]; then
        ngq_unixtime_e=$cmd_endtime
    fi

    # check the custom values ${#ng_custom[@]}
    # There has to be a better way to do this

    if [ $flg_custom -gt 0 ]; then
        if [ ${#ng_custom[0]} -gt 0 ]; then
            ngq_custom_1=${ng_custom[0]}
        fi
        if [ ${#ng_custom[1]} -gt 0 ]; then
            ngq_custom_2=${ng_custom[1]}
        fi
        if [ ${#ng_custom[2]} -gt 0 ]; then
            ngq_custom_3=${ng_custom[2]}
        fi
        if [ ${#ng_custom[3]} -gt 0 ]; then
            ngq_custom_4=${ng_custom[3]}
        fi
        if [ ${#ng_custom[4]} -gt 0 ]; then
            ngq_custom_5=${ng_custom[4]}
        fi
    fi

    ngValues=(
        $ngq_host_name
        $ngq_hostgroup
        $ngq_service
        $ngq_state
        $ngq_current_user
        $ngq_user
        $ngq_unixtime_b
        $ngq_unixtime_e
        $ngq_custom_1
        $ngq_custom_2
        $ngq_custom_3
        $ngq_custom_4
        $ngq_custom_5
    )

    ngVarCount=${#ngVariables[@]}
    ngValCount=${#ngValues[@]}

    # This function isn't used anymore. 
    validateLQL() {
        validLQL=0
        for i in ${LQLprefix[*]}
        do
            prefixLen=${#i}
            if [ "${1:0:$prefixLen}" == "$i" ]; then
                validLQL=1
                return 0
            else
                echo $i doesn\'t look good > /dev/null
            fi
        return 1
        done
    }

    # This function replaces ngVariables in the config file with ngValues
    replaceVariables() {
        incoming=$@
        replaced=0
        count=0
        replaceFail=0
        while [ $count -lt ${#ngVariables[@]} ];
        do
            # echo Looking for ${ngVariables[$count]}
            if [[ $incoming == *${ngVariables[$count]}* ]]; then 
                if [ ${ngValues[$count]} == 'not_set' ]; then
                    echo "Can't replace ${ngVariables[$count]} with ${ngValues[$count]}"
                    replaceFail=1
                else
                    outgoing=$(echo $incoming | sed "s/${ngVariables[$count]}/${ngValues[$count]}/g")
                    if [ ${#outgoing} -gt 0 ]; then
                        replaced=1
                    fi
                fi
            fi
            count=$(( $count + 1 ))
        done
    }

    # This reads the config file looking for a query difinition names 'section' and builds the LQL query
    buildLQL() {
        fnd_section=0
        readLine=0
        while read -r line
        do
            readLine=$(( $readLine + 1 ))
            if [ $fnd_section -eq 1 ]; then fnd_section=2; fi
            # discard comments and blank lines
            if [ ${#line} -gt 0 ]; then
                if [ ${line:0:1} != \# ]; then
                    line=$(echo $line |cut -d# -f1)
                    if [ "$line" == "begin:$section" ]; then
                        if [ $fnd_section -eq 1 ]; then
                            echo Error in $ngq_filename: unexpected 'begin:' at line $readLine
                            exit 1
                        else
                            fnd_section=1
                        fi
                    elif [ "$line" == "end" ] && [ $fnd_section -eq 2 ]; then
                        fnd_section=3
                        break
                    fi

                    if [ $fnd_section -eq 2 ]; then
                        if [ "${line:0:11}" != "description" ] && [ "${line:0:6}" != "author" ]; then
                            #validateLQL $line
                            replaceVariables $line
                            if [ $replaceFail -eq 0 ]; then 
                                if [ $replaced -gt 0 ]; then
                                    line=$outgoing
                                fi
                                if [ ${#lql} -gt 0 ]; then
                                    lql="$lql\n$line"
                                else
                                    lql="$line"
                                fi
                            else
                                echo "Error. Failed to replace unset variables in query $section, ($ngq_filename, line $readLine)"
                                echo "Ensure you provide valid values for your chosen query"
                                exit 2
                            fi
                        fi
                    fi
                fi
            fi
        done < $ngq_filename
    }

    # validateConfig() doe some basic validation of the query configuration file 
    validateConfig() {
        readLine=0
        validation_result='pass'
        validation_state='looking'
        validation_description=0
        validation_line=0

        while read -r line
        do
            readLine=$(( $readLine + 1 ))
            if [ ${#line} -gt 0 ]; then
                #echo Line $readLine: $line
                #echo Prefix ${line:0:5}
                #echo Length ${#line}

                # Checking for 'begin'
                if [ ${#line} -gt 4 ]; then
                    if [ "${line:0:5}" == "begin" ]; then
                        if [ $validation_state == looking ]; then
                            #echo Line is valid - found begin
                            validation_state='in_query'
                            validation_line=1
                        elif [ "$validation_state" == "in_query" ]; then
                            echo Line $readLine: Line is invalid - found 'begin' inside query definition
                            validation_result='fail'
                            validation_line=1
                        fi
                    fi
                fi

                # Checking for 'end'
                if [ ${#line} -gt 2 ]; then
                    if [ "${line:0:3}" == "end" ]; then
                        if [ $validation_state == in_query ]; then
                            if [ $validation_description -gt 0 ]; then
                                #echo Line is valid - found end
                                validation_state='looking'
                                validation_description=0
                                validation_line=1
                            else
                                echo Line $readLine: Line is invalid - found 'end' of query definition without description
                                validation_result='fail'
                                validation_line=1    
                            fi
                        elif [ "$validation_state" == "looking" ]; then
                            echo Line $readLine: Line is invalid - found 'end' outside of query definition
                            validation_result='fail'
                            validation_line=1
                        fi
                    fi
                fi

                # Checking for 'description'
                if [ ${#line} -gt 10 ]; then
                    if [ "${line:0:11}" == "description" ]; then
                        if [ $validation_state == in_query ]; then
                                #echo Line is valid - found description
                                validation_description=1
                                validation_line=1
                        elif [ "$validation_state" == "looking" ]; then
                            echo Line $readLine: Line is invalid - found 'description' outside of query definition
                            validation_result='fail'
                            validation_line=1
                        fi
                    fi
                fi

                # Checking for 'author'
                if [ ${#line} -gt 5 ]; then
                    if [ "${line:0:6}" == "author" ]; then
                        if [ $validation_state == in_query ]; then
                                #echo Line is valid - found description
                                validation_line=1
                        elif [ "$validation_state" == "looking" ]; then
                            echo Line $readLine:  Line is invalid - found 'author' outside of query definition
                            validation_result='fail'
                            validation_line=1
                        fi
                    fi
                fi

                if [ $validation_line -eq 0 ] && [ ${#line} -gt 0 ]; then

                    if [ "${line:0:1}" == "#" ]; then
                        #echo Found comment
                        validation_line=1
                    else 
                        LQL_count=${#LQLprefix[@]}
                        #echo Keywords to check $LQL_count
                        lcounter=0
                        while [ $lcounter -lt $LQL_count ];
                        do
                            keyword=${LQLprefix[$lcounter]}
                            keyword_length=${#keyword}
                            if [ ${#line} -ge $keyword_length ]; then
                                #echo Checking $keyword $keyword_length
                                if [ "${line:0:$keyword_length}" == "$keyword" ]; then
                                
                                    if [ $validation_state == 'in_query' ]; then
                                        validation_line=1
                                    else
                                        echo Line $readLine: LQL keyword found outside of query definition
                                        validation_result='fail'
                                        validation_line=1
                                    fi
                                fi
                            fi
                        lcounter=$(( $lcounter + 1 ))
                        done
                    fi
                fi
            fi
            if [ $validation_line -eq 0 ] && [ ${#line} -gt 0 ]; then
                echo Line $readLine:  Line is invalid - unrecognised
                validation_result='fail'
            fi
            validation_line=0
        done < $ngq_filename

        if [ $validation_result == 'fail' ]; then
            echo -e "\nConfiguration file '$ngq_filename' failed validation tests"
            exit 1
        fi

        return 0

    }

    # This parses the configuration file and lists configured queries
    listQueries(){
        out debug "Listing available queries"
        while read -r line
        do
            if [ ${#line} -ge 5 ]; then
                if [ "${line:0:5}" == "begin" ]; then
                    line=$(echo $line | cut -d# -f1)
                    line=$(echo $line | cut -d: -f2)
                    out ok "\nQuery name:\t$line\n"
                fi
            fi
            if [ ${#line} -ge 11 ]; then
                if [ "${line:0:11}" == "description" ]; then
                    line=$(echo $line | cut -d# -f1)
                    line=$(echo $line | cut -d: -f2)
                    out info "Description:\t$line\n"
                fi
            fi
            if [ ${#line} -ge 6 ]; then
                if [ "${line:0:6}" == "author" ]; then
                    line=$(echo $line | cut -d# -f1)
                    line=$(echo $line | cut -d: -f2)
                    out info "Author:\t\t$line\n"
                fi
            fi
        done < $ngq_filename
        echo -e "\n"
    }

    if [ $flg_validate -gt 0 ]; then
        out INFO "Validating $ngq_filename\n"
        validateConfig
        out info "File $ngq_filename looks valid\n"
        exit 0
    fi

    if [ $flg_custom_query -eq 0 ]; then
        out debug "Validating configuration file $ngq_filename"
        validateConfig
        if [ $? -eq 0 ]; then
            out debug "Configuration file looks valid"
        fi
    fi

    if [ $flg_list -gt 0 ]; then
        out INFO "\nListing queries in $ngq_filename\n"
        listQueries
        exit 0
    fi

    if [ $flg_custom_query -eq 1 ]; then
        lql=$(echo $ngq_custom_query | sed 's/|/\n/g')
    else
        buildLQL
    fi
    if [ ${#lql} -gt 0 ]; then
        if [ $flg_test -gt 0 ] || [ $flg_verbose -gt 0 ] || [ $devMode -gt 0 ]; then
            lql="$lql\n"
            echo -e "\nGot query[\n$lql]\n"
        else 
            out DEBUG "Query:\n$lql"
            out debug "Sending query"
            ngq_result=$(echo -e "$lql\n" | unixcat $env_livestatus)
            if [ ${#ngq_result} -gt 0 ]; then
                echo -e "$ngq_result"
            else
                if [ ${#ngq_null_query_response} -gt 0 ]; then
                    echo -e "$ngq_null_query_response"
                fi
            fi
        fi
    else
        echo Unable to find query for $section
    fi

#   End of query mode code
#------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------
#   Starting rmdown mode

elif [ "$ng_mode" == "rmdown" ]; then
    # echo rmdown mode goes here
    up_err=0

    if [ $fnd_dt_id -eq 0 ]; then
        out err "rmdown mode:"
        out err '    No downtime ID found'
        up_err=1
    fi

    if [ $fnd_begintime -ne 0 ] || [ $fnd_comment -ne 0 ] || [ $fnd_config_filename -ne 0 ] ||
    [ $fnd_custom -ne 0 ] || [ $fnd_endtime -ne 0 ] || [ $fnd_hostgroup -ne 0 ] || [ $fnd_hostname -ne 0 ] ||
    [ $fnd_hosttemplate -ne 0 ] || [ $fnd_hours -ne 0 ] || [ $fnd_minutes -ne 0 ] || [ $fnd_notify -ne 0 ] ||
    [ $fnd_parity -ne 0 ] || [ $fnd_rangex -ne 0 ] || [ $fnd_rangey -ne 0 ] || [ $fnd_service -ne 0 ] ||
    [ $fnd_state -ne 0 ] || [ $fnd_sticky -ne 0 ] || [ $fnd_username -ne 0 ] || [ $flg_my -eq 1 ] ||
    [ $flg_type -eq 1 ] || [ $flg_all -ne 0 ] || [ $fnd_custom_query -ne 0 ] || [ $flg_override -ne 0 ] ||
    [ $flg_quiet -eq 1 ] || [ $fnd_query_name -eq 1 ]  || [ $fnd_nullquery -eq 1 ]; then
        if [ $up_err -eq 0 ]; then out err "up mode:"; fi
        out err '    Invalid parameters specified: rmdown mode requires only -i (downtime entry ID)'
        out err '    Tuning parameters may be specified'
        up_err=1
    fi

    if [ $up_err -eq 1 ]; then exit 12; fi
    
    out debug We have downtime entry $ng_dt_id
    removeDowntime

    # If errors were found, report them and exit
    if [ $flg_error -eq 1 ]; then out err "$ng_error"; exit 1; fi



#   End of rmdown mode code
#------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------
#   Starting up mode code
elif [ "$ng_mode" == "up" ]; then

    out debug 'Starting up mode'
    noQueryParams
    noAckParams

    if [ $flg_my -eq 1 ] && [ $flg_username -eq 1 ]; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tCant't specify --my with -u")
    fi

    if [ $fnd_minutes -eq 1 ]; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tMinutes is not valid in $ng_mode")
    fi

    if [ $fnd_hours -eq 1 ]; then
        flg_error=1
        ng_error=$(echo -e "$ng_error\n\tHours is not valid in $ng_mode")
    fi

    # If generic errors or specific errors were found, report them and exit
    if [ $flg_error -eq 1 ]; then out err "$ng_error"; exit 1; fi

    #Build the LQL query
    ng_filter_hosts=0
    ng_filter_services=0
    out debug 'Building query'
    ng_up_query="GET downtimes"

    if [ $fnd_hostname -eq 1 ] || [ $fnd_hostgroup -eq 1 ]; then
        for ng_host in ${cmd_targets[@]}; do
            ng_up_query="$ng_up_query\nFilter: host_name = $ng_host"
            ng_filter_hosts=$(( $ng_filter_hosts + 1 ))
        done
        ng_up_query="$ng_up_query\nOr: $ng_filter_hosts"
    fi

    if [ $fnd_service -eq 1 ]; then
        for ng_service in ${cmd_services[@]};do
            ng_up_query="$ng_up_query\nFilter: service_description = $ng_service"
            ng_filter_services=$(( $ng_filter_services + 1 ))
        done
        ng_up_query="$ng_up_query\nOr: $ng_filter_services"
    fi

    if [ $fnd_begintime -eq 1 ]; then
        #datefunc absolute $cmd_starttime
        ng_up_query="$ng_up_query\nFilter: start_time = $cmd_starttime"
    fi

    if [ $fnd_endtime -eq 1 ]; then
        #datefunc absolute $cmd_endtime
        ng_up_query="$ng_up_query\nFilter: end_time = $cmd_endtime"
    fi

    if [ $fnd_username -eq 1 ]; then
        ng_up_query="$ng_up_query\nFilter: author = $ng_username"
    fi

    if [ $flg_my -eq 1 ]; then
        ng_up_query="$ng_up_query\nFilter: author = $cmd_user"
    fi

    if [ $fnd_comment -eq 1 ]; then
        ng_up_query="$ng_up_query\nFilter: comment ~ $ng_comment"
    fi

    if [ $flg_type -eq 1 ]; then
        if [ "$ng_type" == "pending" ]; then
            ng_up_query="$ng_up_query\nFilter: type = 1"
        fi

        if [ "$ng_type" == "active" ]; then
            ng_up_query="$ng_up_query\nFilter: type = 0"
        fi
    fi

    ng_up_query="$ng_up_query\nColumns: id"
    ng_up_query="$ng_up_query\n\n"

    out DEBUG "$ng_up_query"

    lql_result=($(echo -e "$ng_up_query" | unixcat $env_livestatus))

    # If there's no result, error and exit
    if [ ${#lql_result[@]} -eq 0 ]; then
        out err "No downtime entry found matching criteria"
        exit 1
    fi

    out debug "Found ${#lql_result[@]} ID(s) matching criteria: $lql_result"

    for id in ${lql_result[@]}; do
        ng_dt_id=$id
        out DEBUG "Removing downtime ID $ng_dt_id"
        removeDowntime
    done

    # If errors were found, report them and exit
    if [ $flg_error -eq 1 ]; then out err "$ng_error"; exit 1; fi

fi

